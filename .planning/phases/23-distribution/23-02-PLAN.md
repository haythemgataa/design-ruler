---
phase: 23-distribution
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - .github/workflows/build-release.yml
  - .github/workflows/update-appcast.yml
  - scripts/generate-appcast.sh
  - scripts/create-dmg-background.sh
autonomous: true

must_haves:
  truths:
    - "Pushing a v* tag triggers the build-release workflow which archives, signs, notarizes, creates DMG, and publishes a draft release"
    - "Publishing a release triggers the update-appcast workflow which generates appcast.xml and attaches it to the release"
    - "DMG has branded background with drag-install layout (app icon left, Applications alias right)"
    - "Appcast XML contains version, EdDSA signature, download URL, and minimum system version"
  artifacts:
    - path: ".github/workflows/build-release.yml"
      provides: "CI workflow: tag-push -> archive -> sign -> notarize -> DMG -> draft release"
    - path: ".github/workflows/update-appcast.yml"
      provides: "CI workflow: release-publish -> download DMG -> sign -> generate appcast.xml -> upload"
    - path: "scripts/generate-appcast.sh"
      provides: "Shell script generating Sparkle appcast.xml from version/signature/size inputs"
    - path: "scripts/create-dmg-background.sh"
      provides: "Shell script generating branded DMG background PNG using sips/CoreGraphics"
  key_links:
    - from: ".github/workflows/build-release.yml"
      to: "App/ExportOptions.plist"
      via: "xcodebuild -exportOptionsPlist"
      pattern: "exportOptionsPlist.*ExportOptions.plist"
    - from: ".github/workflows/build-release.yml"
      to: "App/project.yml"
      via: "xcodegen generate before xcodebuild"
      pattern: "xcodegen generate"
    - from: ".github/workflows/update-appcast.yml"
      to: "scripts/generate-appcast.sh"
      via: "Script invocation in CI step"
      pattern: "generate-appcast.sh"
---

<objective>
Create the CI pipeline (GitHub Actions workflows) and supporting scripts for automated build, sign, notarize, package, and release.

Purpose: The user pushes a version tag and the pipeline produces a notarized DMG as a draft GitHub Release. After manual review and publish, a second workflow generates the Sparkle appcast.xml for auto-updates.

Output: Two GitHub Actions workflows (build-release.yml, update-appcast.yml), appcast generation script, DMG background generation script.
</objective>

<execution_context>
@/Users/haythem/.claude/get-shit-done/workflows/execute-plan.md
@/Users/haythem/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-distribution/23-RESEARCH.md

Key integration points from research:
- Tag format: v1.0.0 (semantic versioning with v prefix)
- CI extracts version from git tag: ${GITHUB_REF_NAME#v}
- Build number: git rev-list --count HEAD (monotonic)
- macos-15 runner (ARM64, Xcode 16.x, Homebrew available)
- Universal binary: ARCHS="$(ARCHS_STANDARD)" produces arm64+x86_64
- xcodegen must run before xcodebuild in CI
- Keychain: create temp keychain, import .p12, unlock, set partition list
- Sparkle sign_update: pipe private key via stdin (--ed-key-file -)
- Notarize: notarytool submit --wait, then stapler staple on DMG
- create-dmg: --background, --window-size 600 400, --icon, --app-drop-link
- Two workflows: build on tag push, appcast on release publish
- Draft release: user reviews and publishes manually
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create build-release workflow and DMG background script</name>
  <files>.github/workflows/build-release.yml, scripts/create-dmg-background.sh</files>
  <action>
**1. Create `.github/workflows/build-release.yml`** — The primary CI workflow triggered on tag push matching `v*`. Must perform the full pipeline:

**Trigger:**
```yaml
on:
  push:
    tags:
      - 'v*'
```

**Runner:** `macos-15`

**Required GitHub Secrets** (referenced in workflow, set by user):
- `DEVELOPER_ID_CERT_BASE64` — Base64-encoded .p12 certificate
- `DEVELOPER_ID_CERT_PASSWORD` — .p12 password
- `KEYCHAIN_PASSWORD` — Random password for temporary CI keychain
- `APPLE_ID` — Apple Developer account email
- `NOTARY_PASSWORD` — App-specific password for notarytool
- `TEAM_ID` — Apple Developer Team ID

NOTE: `SPARKLE_PRIVATE_KEY` is NOT needed in this workflow. EdDSA signing is handled exclusively by the update-appcast workflow.

**Steps (in order):**

1. **Checkout** — `actions/checkout@v4` with `fetch-depth: 0` (needed for `git rev-list --count`)

2. **Extract version** — From tag name:
```bash
VERSION=${GITHUB_REF_NAME#v}
BUILD_NUMBER=$(git rev-list --count HEAD)
echo "VERSION=$VERSION" >> $GITHUB_ENV
echo "BUILD_NUMBER=$BUILD_NUMBER" >> $GITHUB_ENV
```

3. **Install tools** — `brew install create-dmg xcodegen`

4. **Import signing certificate** — Create temporary keychain, import .p12:
```bash
echo -n "$DEVELOPER_ID_CERT_BASE64" | base64 --decode -o $RUNNER_TEMP/certificate.p12
KEYCHAIN_PATH=$RUNNER_TEMP/signing.keychain-db
security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
security import $RUNNER_TEMP/certificate.p12 \
  -P "$DEVELOPER_ID_CERT_PASSWORD" \
  -A -t cert -f pkcs12 \
  -k $KEYCHAIN_PATH
security set-key-partition-list -S apple-tool:,apple: \
  -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
security list-keychain -d user -s $KEYCHAIN_PATH
```

5. **Generate Xcode project** — `cd App && xcodegen generate`

6. **Archive** —
```bash
cd App
xcodebuild archive \
  -project "Design Ruler.xcodeproj" \
  -scheme "Design Ruler" \
  -configuration Release \
  -destination "generic/platform=macOS" \
  -archivePath "$RUNNER_TEMP/DesignRuler.xcarchive" \
  MARKETING_VERSION="$VERSION" \
  CURRENT_PROJECT_VERSION="$BUILD_NUMBER" \
  CODE_SIGN_IDENTITY="Developer ID Application" \
  DEVELOPMENT_TEAM="$TEAM_ID" \
  OTHER_CODE_SIGN_FLAGS="--timestamp --options runtime"
```

7. **Export** —
```bash
cd App
xcodebuild -exportArchive \
  -archivePath "$RUNNER_TEMP/DesignRuler.xcarchive" \
  -exportPath "$RUNNER_TEMP/export" \
  -exportOptionsPlist "ExportOptions.plist"
```

8. **Create DMG background** — Run `scripts/create-dmg-background.sh` to generate the background PNG.

9. **Extract volume icon from app bundle** — The exported .app contains the app's .icns file which is used as the custom DMG volume icon (per user decision: "Custom volume icon using the app icon"):
```bash
VOLICON=$(find "$RUNNER_TEMP/export/Design Ruler.app/Contents/Resources" -name "*.icns" | head -1)
echo "VOLICON=$VOLICON" >> $GITHUB_ENV
```

10. **Create DMG** —
```bash
create-dmg \
  --volname "Design Ruler" \
  --volicon "$VOLICON" \
  --background "$RUNNER_TEMP/dmg-background.png" \
  --window-pos 200 120 \
  --window-size 600 400 \
  --icon-size 128 \
  --icon "Design Ruler.app" 150 200 \
  --app-drop-link 450 200 \
  --hide-extension "Design Ruler.app" \
  --no-internet-enable \
  "$RUNNER_TEMP/Design-Ruler-$VERSION.dmg" \
  "$RUNNER_TEMP/export/"
```
NOTE: create-dmg may exit with code 2 on "warnings". Use `|| true` if needed, but verify the DMG was actually created.

11. **Notarize DMG** —
```bash
xcrun notarytool store-credentials "notary-profile" \
  --apple-id "$APPLE_ID" \
  --team-id "$TEAM_ID" \
  --password "$NOTARY_PASSWORD"
xcrun notarytool submit "$RUNNER_TEMP/Design-Ruler-$VERSION.dmg" \
  --keychain-profile "notary-profile" \
  --wait
xcrun stapler staple "$RUNNER_TEMP/Design-Ruler-$VERSION.dmg"
```

12. **Create draft release** —
```bash
gh release create "$GITHUB_REF_NAME" \
  "$RUNNER_TEMP/Design-Ruler-$VERSION.dmg" \
  --draft \
  --title "Design Ruler $VERSION" \
  --generate-notes
```
Uses `GITHUB_TOKEN` (automatic).

13. **Cleanup keychain** — Always run (even on failure):
```bash
security delete-keychain $RUNNER_TEMP/signing.keychain-db 2>/dev/null || true
```

**Environment:** Each secret must be referenced via `${{ secrets.SECRET_NAME }}`. Use `env:` blocks to map secrets to environment variables. Mark the keychain cleanup step with `if: always()`.

**2. Create `scripts/create-dmg-background.sh`** — Shell script that generates a branded DMG background PNG (1200x800 @2x for 600x400 window). Use Python with Pillow (pre-installed on macos-15 runners) or a simpler approach:

Use `sips` and `python3` with the built-in `Pillow` or fall back to creating a simple gradient/solid background using Python's built-in modules. The simplest approach that works on the CI runner:

```bash
#!/bin/bash
# Generate a branded DMG background image (1200x800 @2x for 600x400 window)
# Output: $RUNNER_TEMP/dmg-background.png (or first argument)
set -euo pipefail

OUTPUT="${1:-$RUNNER_TEMP/dmg-background.png}"

python3 << 'PYEOF'
import struct, zlib, sys, os

output = sys.argv[1] if len(sys.argv) > 1 else os.environ.get("RUNNER_TEMP", "/tmp") + "/dmg-background.png"

# 1200x800 image (2x for Retina 600x400 window)
W, H = 1200, 800

# Create raw pixel data - clean white/light gray gradient
rows = []
for y in range(H):
    row = b'\x00'  # filter byte
    # Subtle vertical gradient: #FAFAFA at top to #F0F0F0 at bottom
    v = int(250 - (y / H) * 10)
    row += bytes([v, v, v]) * W
    rows.append(row)

raw = b''.join(rows)

# Minimal PNG encoder
def png_chunk(chunk_type, data):
    chunk = chunk_type + data
    return struct.pack('>I', len(data)) + chunk + struct.pack('>I', zlib.crc32(chunk) & 0xFFFFFFFF)

with open(output, 'wb') as f:
    f.write(b'\x89PNG\r\n\x1a\n')
    f.write(png_chunk(b'IHDR', struct.pack('>IIBBBBB', W, H, 8, 2, 0, 0, 0)))
    compressed = zlib.compress(raw)
    f.write(png_chunk(b'IDAT', compressed))
    f.write(png_chunk(b'IEND', b''))

print(f"Created DMG background: {output}")
PYEOF "$OUTPUT"
```

This creates a clean, subtle gradient background. The drag-install layout (app icon position, Applications alias) is handled by create-dmg flags, not the background image. The background just needs to be a clean, branded canvas.

Make the script executable: `chmod +x scripts/create-dmg-background.sh`
  </action>
  <verify>
```bash
# Verify workflow YAML is valid
python3 -c "import yaml; yaml.safe_load(open('.github/workflows/build-release.yml'))"
# Verify script is executable
test -x scripts/create-dmg-background.sh && echo "OK: executable"
# Verify script runs (generates image)
bash scripts/create-dmg-background.sh /tmp/test-dmg-bg.png && file /tmp/test-dmg-bg.png
```
  </verify>
  <done>build-release.yml workflow exists with tag trigger, full signing/notarization pipeline, DMG creation, and draft release. DMG background script generates a valid PNG.</done>
</task>

<task type="auto">
  <name>Task 2: Create update-appcast workflow and appcast generation script</name>
  <files>.github/workflows/update-appcast.yml, scripts/generate-appcast.sh</files>
  <action>
**1. Create `scripts/generate-appcast.sh`** — Shell script that generates a Sparkle appcast.xml file from input parameters. Takes version, build number, EdDSA signature, file length, and download URL as arguments or environment variables.

```bash
#!/bin/bash
# Generate Sparkle appcast.xml
# Usage: ./generate-appcast.sh
# Required env vars: VERSION, BUILD_NUMBER, ED_SIGNATURE, FILE_LENGTH, DOWNLOAD_URL, REPO_URL
set -euo pipefail

OUTPUT="${1:-appcast.xml}"

cat > "$OUTPUT" << EOF
<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
     xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle"
     xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Design Ruler Updates</title>
    <link>${REPO_URL}</link>
    <description>Most recent changes with links to updates.</description>
    <language>en</language>
    <item>
      <title>Version ${VERSION}</title>
      <pubDate>$(date -u "+%a, %d %b %Y %H:%M:%S +0000")</pubDate>
      <sparkle:version>${BUILD_NUMBER}</sparkle:version>
      <sparkle:shortVersionString>${VERSION}</sparkle:shortVersionString>
      <sparkle:minimumSystemVersion>14.0</sparkle:minimumSystemVersion>
      <enclosure
        url="${DOWNLOAD_URL}"
        sparkle:edSignature="${ED_SIGNATURE}"
        length="${FILE_LENGTH}"
        type="application/octet-stream" />
    </item>
  </channel>
</rss>
EOF

echo "Generated appcast: $OUTPUT"
```

Make executable: `chmod +x scripts/generate-appcast.sh`

**2. Create `.github/workflows/update-appcast.yml`** — Second workflow triggered when a release is published (user manually publishes the draft created by build-release.yml).

**Trigger:**
```yaml
on:
  release:
    types: [published]
```

**Runner:** `macos-15` (needed for Sparkle sign_update binary)

**Required Secrets:** `SPARKLE_PRIVATE_KEY`

**Steps:**

1. **Checkout** — `actions/checkout@v4` with `fetch-depth: 0`

2. **Extract release info** — Get version from release tag, download URL from release assets:
```bash
VERSION=${GITHUB_REF_NAME#v}
BUILD_NUMBER=$(git rev-list --count HEAD)
DMG_NAME="Design-Ruler-$VERSION.dmg"
DOWNLOAD_URL="https://github.com/$GITHUB_REPOSITORY/releases/download/$GITHUB_REF_NAME/$DMG_NAME"
```

3. **Download DMG from release** —
```bash
gh release download "$GITHUB_REF_NAME" \
  --pattern "*.dmg" \
  --dir "$RUNNER_TEMP"
```

4. **Download Sparkle tools** — Same as build-release workflow:
```bash
curl -sL "https://github.com/sparkle-project/Sparkle/releases/download/2.8.1/Sparkle-2.8.1.tar.xz" \
  -o /tmp/Sparkle.tar.xz
mkdir -p /tmp/sparkle-tools
tar xf /tmp/Sparkle.tar.xz -C /tmp/sparkle-tools
```

5. **Generate EdDSA signature** — Pipe private key via stdin:
```bash
SIGN_OUTPUT=$(echo "$SPARKLE_PRIVATE_KEY" | /tmp/sparkle-tools/bin/sign_update --ed-key-file - "$RUNNER_TEMP/$DMG_NAME")
ED_SIGNATURE=$(echo "$SIGN_OUTPUT" | sed -n 's/.*sparkle:edSignature="\([^"]*\)".*/\1/p')
FILE_LENGTH=$(echo "$SIGN_OUTPUT" | sed -n 's/.*length="\([^"]*\)".*/\1/p')
```

6. **Generate appcast.xml** —
```bash
export VERSION BUILD_NUMBER ED_SIGNATURE FILE_LENGTH DOWNLOAD_URL
export REPO_URL="https://github.com/$GITHUB_REPOSITORY"
chmod +x scripts/generate-appcast.sh
scripts/generate-appcast.sh "$RUNNER_TEMP/appcast.xml"
```

7. **Upload appcast.xml to release** —
```bash
gh release upload "$GITHUB_REF_NAME" \
  "$RUNNER_TEMP/appcast.xml" \
  --clobber
```
The `--clobber` flag overwrites if appcast.xml already exists on that release.

**Permissions:** The workflow needs `contents: write` permission for `gh release upload`.

NOTE: The appcast.xml contains only the latest release item (not cumulative history). Sparkle checks `sparkle:version` against the app's CFBundleVersion to determine if an update is available. For a v1 pipeline, single-item appcast is sufficient. The `SUFeedURL` in Info.plist points to `releases/latest/download/appcast.xml` which always resolves to the most recent release's appcast.xml.
  </action>
  <verify>
```bash
# Verify workflow YAML is valid
python3 -c "import yaml; yaml.safe_load(open('.github/workflows/update-appcast.yml'))"
# Verify script is executable and runs with test data
VERSION=1.0.0 BUILD_NUMBER=42 ED_SIGNATURE=test123 FILE_LENGTH=1234 DOWNLOAD_URL=https://example.com/test.dmg REPO_URL=https://github.com/test/repo scripts/generate-appcast.sh /tmp/test-appcast.xml
xmllint --noout /tmp/test-appcast.xml
cat /tmp/test-appcast.xml
```
  </verify>
  <done>update-appcast.yml workflow exists with release-publish trigger, DMG download, EdDSA signing, appcast generation, and upload. generate-appcast.sh produces valid Sparkle appcast XML.</done>
</task>

</tasks>

<verification>
1. `.github/workflows/build-release.yml` is valid YAML with tag-push trigger
2. `.github/workflows/update-appcast.yml` is valid YAML with release-publish trigger
3. `scripts/generate-appcast.sh` is executable and produces valid XML
4. `scripts/create-dmg-background.sh` is executable and produces a PNG
5. Workflows reference all required secrets (DEVELOPER_ID_CERT_BASE64, DEVELOPER_ID_CERT_PASSWORD, KEYCHAIN_PASSWORD, APPLE_ID, NOTARY_PASSWORD, TEAM_ID, SPARKLE_PRIVATE_KEY)
6. build-release.yml includes keychain cleanup with `if: always()`
7. Both workflows use macos-15 runner
8. EdDSA key is piped via stdin (never written to disk)
</verification>

<success_criteria>
Two GitHub Actions workflows and two supporting scripts exist. The build-release workflow handles the full sign/notarize/package pipeline on tag push. The update-appcast workflow generates Sparkle appcast.xml on release publish. Scripts are executable and produce valid output.
</success_criteria>

<output>
After completion, create `.planning/phases/23-distribution/23-02-SUMMARY.md`
</output>
