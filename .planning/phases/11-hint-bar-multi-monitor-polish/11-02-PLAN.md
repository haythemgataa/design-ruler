---
phase: 11-hint-bar-multi-monitor-polish
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - swift/Ruler/Sources/AlignmentGuides/AlignmentGuides.swift
  - swift/Ruler/Sources/AlignmentGuides/AlignmentGuidesWindow.swift
  - swift/Ruler/Sources/AlignmentGuides/GuideLineManager.swift
autonomous: true

must_haves:
  truths:
    - "One fullscreen window per connected screen with frozen screenshot background"
    - "All screens captured BEFORE any windows created (no overlay artifacts)"
    - "Cursor moves across screens and preview line follows seamlessly"
    - "Placed lines persist on their screen when cursor moves to another"
    - "Color cycling applies globally across all screens"
    - "ESC closes all windows instantly"
    - "Hint bar shows on cursor screen with alignment guides content"
    - "Hint bar collapses after 3 seconds on first mouse move"
    - "Hint bar repositions bottom-to-top when cursor approaches"
    - "Remove-state-stuck bug is fixed (resetRemoveMode called after removal)"
  artifacts:
    - path: "swift/Ruler/Sources/AlignmentGuides/AlignmentGuides.swift"
      provides: "Multi-monitor window setup, capture-before-window, global color state, hint bar collapse"
      contains: "for screen in NSScreen.screens"
    - path: "swift/Ruler/Sources/AlignmentGuides/AlignmentGuidesWindow.swift"
      provides: "Hint bar integration, activate/deactivate, remove state fix, key press/release"
      contains: "hintBarView"
  key_links:
    - from: "swift/Ruler/Sources/AlignmentGuides/AlignmentGuides.swift"
      to: "swift/Ruler/Sources/AlignmentGuides/AlignmentGuidesWindow.swift"
      via: "Creates one window per screen, wires onActivate callback"
      pattern: "AlignmentGuidesWindow\\.create"
    - from: "swift/Ruler/Sources/AlignmentGuides/AlignmentGuidesWindow.swift"
      to: "swift/Ruler/Sources/Rendering/HintBarView.swift"
      via: "Creates HintBarView, sets mode to .alignmentGuides, calls configure"
      pattern: "setMode.*alignmentGuides"
    - from: "swift/Ruler/Sources/AlignmentGuides/AlignmentGuidesWindow.swift"
      to: "swift/Ruler/Sources/AlignmentGuides/GuideLineManager.swift"
      via: "Calls resetRemoveMode() after removeLine()"
      pattern: "resetRemoveMode"
---

<objective>
Multi-monitor window management + hint bar integration + remove-state-stuck fix wiring.

Purpose: Enable alignment guides on all connected screens with independent overlays, integrate the hint bar with alignment-guides-specific content and collapse behavior, and wire the remove-state reset to fix the stuck bug.

Output: Updated AlignmentGuides.swift with per-screen window creation, updated AlignmentGuidesWindow.swift with hint bar, activation/deactivation, and remove fix.
</objective>

<execution_context>
@/Users/haythem/.claude/get-shit-done/workflows/execute-plan.md
@/Users/haythem/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-hint-bar-multi-monitor-polish/11-01-SUMMARY.md

@swift/Ruler/Sources/AlignmentGuides/AlignmentGuides.swift
@swift/Ruler/Sources/AlignmentGuides/AlignmentGuidesWindow.swift
@swift/Ruler/Sources/AlignmentGuides/GuideLineManager.swift
@swift/Ruler/Sources/Ruler.swift
@swift/Ruler/Sources/RulerWindow.swift
@swift/Ruler/Sources/Rendering/HintBarView.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Multi-monitor capture-before-window + hint bar integration in AlignmentGuides</name>
  <files>
    swift/Ruler/Sources/AlignmentGuides/AlignmentGuides.swift
  </files>
  <action>
Rewrite AlignmentGuides.run() to mirror Ruler.swift's multi-monitor pattern exactly. The key changes:

**1. Add properties for hint bar collapse timing (mirror Ruler.swift):**
```swift
private var launchTime: CFAbsoluteTime = 0
private let minExpandedDuration: TimeInterval = 3
```

**2. Add shared color state property:**
```swift
private(set) var currentStyle: GuideLineStyle = .dynamic
```

**3. Rewrite run() method — capture ALL screens before creating ANY windows:**
```swift
func run(hideHintBar: Bool) {
    // Permission check (existing)

    // Find cursor screen (existing)

    // CRITICAL: Capture ALL screens BEFORE creating ANY windows
    var captures: [(screen: NSScreen, image: CGImage?)] = []
    for screen in NSScreen.screens {
        let cgImage = captureScreen(screen)
        captures.append((screen, cgImage))
    }

    let app = NSApplication.shared
    app.setActivationPolicy(.accessory)

    // Close previous windows (existing cleanup)
    for oldWindow in windows {
        oldWindow.orderOut(nil)
        oldWindow.close()
    }
    windows.removeAll()
    activeWindow = nil
    firstMoveReceived = false
    currentStyle = .dynamic  // Reset shared color state

    // Create one window per screen
    for capture in captures {
        let isCursorScreen = capture.screen === cursorScreen
        let window = AlignmentGuidesWindow.create(
            for: capture.screen,
            screenshot: capture.image,
            hideHintBar: isCursorScreen ? hideHintBar : true  // Hint bar only on cursor screen
        )

        if let img = capture.image {
            window.setBackground(img)
        }

        // Wire callbacks
        window.onActivate = { [weak self] window in
            self?.activateWindow(window)
        }
        window.onRequestExit = { [weak self] in
            self?.handleExit()
        }
        window.onFirstMove = { [weak self] in
            self?.handleFirstMove()
        }
        window.onActivity = { [weak self] in
            self?.resetInactivityTimer()
        }
        window.onStyleChanged = { [weak self] newStyle in
            self?.currentStyle = newStyle
        }

        windows.append(window)
    }

    // Show all windows
    for window in windows {
        window.orderFrontRegardless()
    }

    // Make cursor screen window key and show initial state
    let cursorWindow = windows.first { $0.targetScreen === cursorScreen } ?? windows.first!
    cursorWindow.makeKey()
    cursorWindow.showInitialState()
    activeWindow = cursorWindow

    launchTime = CFAbsoluteTimeGetCurrent()
    NSApp.activate(ignoringOtherApps: true)
    setupSignalHandler()
    resetInactivityTimer()
    app.run()
}
```

**4. Update activateWindow() to sync color state:**
```swift
private func activateWindow(_ window: AlignmentGuidesWindow) {
    resetInactivityTimer()
    guard window !== activeWindow else { return }

    activeWindow?.deactivate()
    activeWindow = window
    window.makeKey()
    window.activate(firstMoveAlreadyReceived: firstMoveReceived, currentStyle: currentStyle)
}
```

**5. Update handleFirstMove() — add hint bar collapse with 3-second minimum (mirror Ruler.swift):**
```swift
private func handleFirstMove() {
    firstMoveReceived = true
    let elapsed = CFAbsoluteTimeGetCurrent() - launchTime
    let remaining = minExpandedDuration - elapsed
    if remaining > 0 {
        DispatchQueue.main.asyncAfter(deadline: .now() + remaining) { [weak self] in
            self?.activeWindow?.collapseHintBar()
        }
    } else {
        activeWindow?.collapseHintBar()
    }
}
```

**6. Add onStyleChanged callback for global color cycling:**
Add a new callback `onStyleChanged` to the window to propagate color changes to the coordinator. This keeps color state in AlignmentGuides (singleton), synced to all windows on activation.
  </action>
  <verify>Build: `cd /Users/haythem/conductor/workspaces/design-ruler-v1/rabat/swift/Ruler && swift build 2>&1 | tail -5` compiles. Grep for `for screen in NSScreen.screens` in AlignmentGuides.swift, verify `captures` array pattern, verify `minExpandedDuration`, verify `onStyleChanged`.</verify>
  <done>AlignmentGuides captures all screens before creating windows. One window per screen. Hint bar only on cursor screen. Collapse timing with 3-second minimum. Shared color state synced via onStyleChanged callback.</done>
</task>

<task type="auto">
  <name>Task 2: Window hint bar + activate/deactivate + remove-state fix + key events</name>
  <files>
    swift/Ruler/Sources/AlignmentGuides/AlignmentGuidesWindow.swift
  </files>
  <action>
Update AlignmentGuidesWindow with hint bar integration, multi-monitor activation/deactivation, remove-state fix, and key press/release events.

**1. Add properties:**
```swift
private var hintBarView: HintBarView!
var onStyleChanged: ((GuideLineStyle) -> Void)?
```

**2. Update setupViews() — add hint bar with alignment guides mode:**
After creating the guideline view and GuideLineManager, add:
```swift
let hv = HintBarView(frame: .zero)
self.hintBarView = hv
if !hideHintBar {
    hv.setMode(.alignmentGuides)
    hv.configure(screenWidth: size.width, screenHeight: size.height, screenshot: screenshot)
    containerView.addSubview(hv)
}
```
The `setMode(.alignmentGuides)` call MUST come before `configure()` so the correct SwiftUI content views are created.

**3. Add showInitialState() and collapseHintBar() methods (mirror RulerWindow pattern):**
```swift
func showInitialState() {
    if hintBarView.superview != nil { hintBarView.animateEntrance() }
}

func collapseHintBar() {
    guard hintBarView.superview != nil else { return }
    hintBarView.animateToCollapsed()
}
```

**4. Implement deactivate() — clear hover state via off-screen point:**
```swift
func deactivate() {
    if guideLineManager.hasHoveredLine {
        guideLineManager.updateHover(at: NSPoint(x: -100, y: -100))
        if CursorManager.shared.state == .pointingHand {
            CursorManager.shared.transitionBackToSystem()
            updateCursor()
        }
    }
}
```
Preview line stays at last position on the deactivated screen (static, no visual issue). On reactivation, `updatePreview` is called immediately with the current cursor position.

**5. Implement activate() — sync color state, update preview:**
```swift
func activate(firstMoveAlreadyReceived: Bool, currentStyle: GuideLineStyle) {
    guideLineManager.setPreviewStyle(currentStyle)
    let mouse = NSEvent.mouseLocation
    let wp = NSPoint(x: mouse.x - screenBounds.origin.x, y: mouse.y - screenBounds.origin.y)
    guideLineManager.updatePreview(at: wp)
    if hintBarView.superview != nil {
        hintBarView.updatePosition(cursorY: wp.y, screenHeight: screenBounds.height)
    }
}
```

**6. Fix mouseDown — wire resetRemoveMode() after removal (CRITICAL):**
In `mouseDown(with:)`, after `guideLineManager.removeLine()`, add:
```swift
guideLineManager.resetRemoveMode()
guideLineManager.updatePreview(at: windowPoint)
CursorManager.shared.transitionBackToSystem()
updateCursor()
```

**7. Update mouseMoved — add hint bar position update:**
After `guideLineManager.updatePreview(at: windowPoint)`, add:
```swift
if hintBarView.superview != nil {
    hintBarView.updatePosition(cursorY: windowPoint.y, screenHeight: screenBounds.height)
}
```

**8. Update keyDown/keyUp — key press visual feedback + propagate style changes:**
In `keyDown`: for tab (keyCode 48), call `hintBarView.pressKey(.tab)` then `toggleDirection()`. For space (49), call `hintBarView.pressKey(.space)` then `cycleStyle()` and `onStyleChanged?(guideLineManager.currentStyleValue)`. For esc (53), call `hintBarView.pressKey(.esc)` then `onRequestExit?()`.

Add `keyUp` override: for tab/space, call `hintBarView.releaseKey(.tab)` / `.releaseKey(.space)`.

**9. Add trivial GuideLineManager methods (1-line each):**
Add to GuideLineManager.swift:
- `func setPreviewStyle(_ style: GuideLineStyle) { currentStyle = style }` — setter for global color sync
- `var currentStyleValue: GuideLineStyle { currentStyle }` — getter to expose current style
  </action>
  <verify>Build: `cd /Users/haythem/conductor/workspaces/design-ruler-v1/rabat/swift/Ruler && swift build 2>&1 | tail -5` compiles. Grep for `hintBarView` in AlignmentGuidesWindow.swift, verify `resetRemoveMode()` call in mouseDown, verify `setMode(.alignmentGuides)` call, verify `onStyleChanged`, verify `keyUp` method exists.</verify>
  <done>AlignmentGuidesWindow has hint bar with alignment guides mode. Activate/deactivate handle multi-monitor transitions. Remove-state-stuck bug fixed via resetRemoveMode() call. Key press/release events provide visual feedback on hint bar keycaps. Color state propagated via onStyleChanged callback.</done>
</task>

</tasks>

<verification>
1. `swift build` succeeds in swift/Ruler directory
2. AlignmentGuides.swift captures all screens before creating windows (no overlay artifacts)
3. One window per screen, hint bar only on cursor screen
4. Hint bar shows alignment guides content (tab + space + esc keycaps)
5. Hint bar collapses after 3 seconds on first mouse move
6. Activate/deactivate handle multi-monitor transitions
7. mouseDown calls resetRemoveMode() after removeLine() (remove-state-stuck fix)
8. Key press/release provide visual hint bar feedback
9. Color cycling propagated globally via onStyleChanged
10. Existing inspect command behavior unchanged
</verification>

<success_criteria>
- Multi-monitor support: one window per screen, capture before window, seamless cursor transitions
- Hint bar: alignment guides content, collapse animation, bottom-top repositioning
- Remove-state fix: wired in mouseDown
- Key events: visual feedback on tab/space/esc keycaps
- Build succeeds, no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/11-hint-bar-multi-monitor-polish/11-02-SUMMARY.md`
</output>
