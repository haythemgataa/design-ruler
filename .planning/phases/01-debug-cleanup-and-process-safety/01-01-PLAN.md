---
phase: 01-debug-cleanup-and-process-safety
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - swift/Ruler/Sources/EdgeDetection/EdgeDetector.swift
  - swift/Ruler/Sources/RulerWindow.swift
  - swift/Ruler/Sources/Ruler.swift
autonomous: true

must_haves:
  truths:
    - "Running the extension produces no output on stderr"
    - "Leaving the extension idle for 10 minutes causes it to exit cleanly"
    - "After timeout exit, no Ruler processes remain visible in ps aux"
  artifacts:
    - path: "swift/Ruler/Sources/EdgeDetection/EdgeDetector.swift"
      provides: "Edge detection without debug output"
      contains_not: "fputs"
    - path: "swift/Ruler/Sources/RulerWindow.swift"
      provides: "Event handling without debug output, with activity callback"
      contains_not: "fputs"
      contains: "onActivity"
    - path: "swift/Ruler/Sources/Ruler.swift"
      provides: "Process lifecycle with inactivity timer"
      contains: "inactivityTimer"
  key_links:
    - from: "swift/Ruler/Sources/RulerWindow.swift"
      to: "swift/Ruler/Sources/Ruler.swift"
      via: "onActivity callback fires on every user event"
      pattern: "onActivity\\?"
    - from: "swift/Ruler/Sources/Ruler.swift"
      to: "swift/Ruler/Sources/Ruler.swift"
      via: "Timer fires handleExit() after 600s inactivity"
      pattern: "Timer\\.scheduledTimer.*inactivityTimeout"
---

<objective>
Remove all debug fputs output from production code and add a 10-minute inactivity watchdog timer to prevent zombie processes.

Purpose: Ensures the extension produces zero stderr noise in production and self-terminates when idle, preventing orphaned processes from accumulating.
Output: Clean production builds with automatic process lifecycle management.
</objective>

<execution_context>
@/Users/haythem/.claude/get-shit-done/workflows/execute-plan.md
@/Users/haythem/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-debug-cleanup-and-process-safety/01-RESEARCH.md
@swift/Ruler/Sources/EdgeDetection/EdgeDetector.swift
@swift/Ruler/Sources/RulerWindow.swift
@swift/Ruler/Sources/Ruler.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Remove all fputs debug output</name>
  <files>
    swift/Ruler/Sources/EdgeDetection/EdgeDetector.swift
    swift/Ruler/Sources/RulerWindow.swift
  </files>
  <action>
Remove all 6 fputs calls entirely (do NOT gate with `#if DEBUG` -- Raycast always builds in debug config, so `#if DEBUG` is always true and provides zero protection).

In EdgeDetector.swift:
1. Line 36: Remove `fputs("[DEBUG] screen.frame(AppKit)=\(frame) cgRect=\(cgRect) ...` -- this logs capture dimensions after CGWindowListCreateImage. Delete the entire fputs line.
2. Line 75: Remove `fputs("[DEBUG] onMouseMoved: currentEdges returned nil ...` -- this logs nil edges on mouse move. Delete the entire fputs line including the `if edges == nil { ... }` block that wraps it (the nil check + fputs block, lines 74-76). The nil return is handled by the caller.

In RulerWindow.swift:
3. Line 226: Remove `fputs("[DEBUG] mouseDown: isDragging was still true ...` -- inside the stale drag reset block in mouseDown. Delete only the fputs line; keep the surrounding if-block and its other statements (isDragging = false, crosshairView.showAfterDrag(), cursor restoration).
4. Line 252: Remove `fputs("[DEBUG] mouseDown: starting drag at ...` -- logs drag start. Delete the entire fputs line.
5. Line 272: Remove `fputs("[DEBUG] mouseDragged: rejected ...` -- inside mouseDragged guard. Delete only the fputs line; keep the `if !isDragging { return }` guard.
6. Line 281: Remove `fputs("[DEBUG] mouseUp: rejected ...` -- inside mouseUp guard. Delete only the fputs line; keep the `if !isDragging { return }` guard.

IMPORTANT: Do NOT remove any logic besides the fputs calls and the nil-check wrapper in EdgeDetector.swift. All guard statements, if-blocks, and cursor management code must remain intact.
  </action>
  <verify>
Run: `cd /Users/haythem/Developer/design-ruler && grep -rn "fputs" swift/Ruler/Sources/`
Expected: zero matches.

Run: `cd /Users/haythem/Developer/design-ruler/swift/Ruler && swift build 2>&1 | tail -5`
Expected: "Build complete!" with no errors.
  </verify>
  <done>Zero fputs calls remain in any Swift source file. Project compiles without errors.</done>
</task>

<task type="auto">
  <name>Task 2: Add 10-minute inactivity watchdog timer</name>
  <files>
    swift/Ruler/Sources/Ruler.swift
    swift/Ruler/Sources/RulerWindow.swift
  </files>
  <action>
Add a non-repeating Foundation Timer to Ruler.swift that calls handleExit() after 10 minutes of inactivity, reset on every user interaction.

In Ruler.swift:

1. Add two private properties to the Ruler class:
   ```swift
   private var inactivityTimer: Timer?
   private let inactivityTimeout: TimeInterval = 600 // 10 minutes
   ```

2. Add a private method `resetInactivityTimer()`:
   ```swift
   private func resetInactivityTimer() {
       inactivityTimer?.invalidate()
       inactivityTimer = Timer.scheduledTimer(
           withTimeInterval: inactivityTimeout,
           repeats: false
       ) { [weak self] _ in
           self?.handleExit()
       }
   }
   ```
   This invalidates any existing timer and schedules a new one. Uses `weak self` to avoid retain cycles. Routes through existing `handleExit()` which already handles cursor restoration and NSApp.terminate.

3. In `run()`, just before the `app.run()` call at the end of the method, add:
   ```swift
   resetInactivityTimer()
   ```
   This starts the watchdog. The timer is scheduled on the main run loop, which `app.run()` then drives.

4. Wire the `onActivity` callback when setting up each window's callbacks (in the `for capture in captures` loop, alongside onActivate/onRequestExit/onFirstMove):
   ```swift
   rulerWindow.onActivity = { [weak self] in
       self?.resetInactivityTimer()
   }
   ```

5. Also reset the timer in `activateWindow(_:)` (screen switch is user activity):
   Add `resetInactivityTimer()` at the beginning of `activateWindow(_:)`, before the guard.

In RulerWindow.swift:

6. Add a new callback property alongside the existing ones (near onActivate, onRequestExit, onFirstMove):
   ```swift
   var onActivity: (() -> Void)?
   ```

7. Call `onActivity?()` at the START of these event handlers (before any early returns):
   - `mouseMoved(with:)` -- after the throttle guard (line ~179), before the firstMove check. This is the most frequent event.
   - `keyDown(with:)` -- at the very start, before the switch statement.
   - `mouseDown(with:)` -- at the very start, before the stale drag reset.
   - `mouseDragged(with:)` -- at the very start, before the isDragging guard.
   - `mouseUp(with:)` -- at the very start, before the isDragging guard.

   Do NOT call onActivity from mouseEntered -- that already routes through onActivate -> activateWindow which resets the timer.

IMPORTANT: The timer must be started BEFORE `app.run()` so it's scheduled on the main run loop. `app.run()` then drives that run loop. Do NOT use DispatchQueue.main.asyncAfter (can't cancel). Do NOT use a repeating timer (unnecessary complexity). Do NOT put timer logic in RulerWindow (belongs in Ruler, the lifecycle coordinator).
  </action>
  <verify>
Run: `cd /Users/haythem/Developer/design-ruler && grep -n "inactivityTimer\|resetInactivityTimer\|onActivity" swift/Ruler/Sources/Ruler.swift swift/Ruler/Sources/RulerWindow.swift`
Expected: inactivityTimer property and resetInactivityTimer method in Ruler.swift, onActivity property and calls in RulerWindow.swift.

Run: `cd /Users/haythem/Developer/design-ruler/swift/Ruler && swift build 2>&1 | tail -5`
Expected: "Build complete!" with no errors.

Run: `cd /Users/haythem/Developer/design-ruler && grep -c "onActivity?()" swift/Ruler/Sources/RulerWindow.swift`
Expected: 5 (one in each of: mouseMoved, keyDown, mouseDown, mouseDragged, mouseUp).
  </verify>
  <done>Ruler.swift has inactivityTimer property, resetInactivityTimer() method, timer started before app.run(), and onActivity wired to each window. RulerWindow.swift has onActivity callback property called from all 5 user-event handlers. Project compiles without errors.</done>
</task>

</tasks>

<verification>
1. `grep -rn "fputs" swift/Ruler/Sources/` returns zero matches
2. `grep -n "inactivityTimer" swift/Ruler/Sources/Ruler.swift` shows property and timer scheduling
3. `grep -c "onActivity?()" swift/Ruler/Sources/RulerWindow.swift` returns 5
4. `cd swift/Ruler && swift build` succeeds with no errors
5. No `#if DEBUG` gating was used (confirmed by absence)
</verification>

<success_criteria>
- Zero fputs calls in any Swift source file
- Ruler.swift contains inactivity timer with 600s timeout routed through handleExit()
- RulerWindow.swift fires onActivity callback from all 5 event handlers
- Swift project compiles successfully
- Timer is started before app.run() in Ruler.run()
</success_criteria>

<output>
After completion, create `.planning/phases/01-debug-cleanup-and-process-safety/01-01-SUMMARY.md`
</output>
