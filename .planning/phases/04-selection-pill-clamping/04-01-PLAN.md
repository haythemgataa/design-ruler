---
phase: 04-selection-pill-clamping
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - swift/Ruler/Sources/Rendering/SelectionOverlay.swift
autonomous: true

must_haves:
  truths:
    - "Selection pill near left screen edge stays fully visible (including shadow)"
    - "Selection pill near right screen edge stays fully visible (including shadow)"
    - "Selection pill near bottom screen edge flips above, or clamps if both positions overflow"
    - "Selection pill in a screen corner is visible on both axes simultaneously"
    - "Drop shadow is not clipped at any screen edge"
  artifacts:
    - path: "swift/Ruler/Sources/Rendering/SelectionOverlay.swift"
      provides: "Screen-bounds clamping for selection pill"
      contains: "screenSize"
  key_links:
    - from: "SelectionOverlay.init"
      to: "screenSize property"
      via: "parentLayer.bounds.size captured at construction"
      pattern: "self\\.screenSize\\s*=\\s*parentLayer\\.bounds\\.size"
    - from: "SelectionOverlay.layoutPill()"
      to: "screenSize"
      via: "min/max clamping of pillX and pillY"
      pattern: "min\\(max\\(pill[XY]"
---

<objective>
Add screen-bounds clamping to the selection overlay dimension pill so it never renders partially off-screen, including its drop shadow.

Purpose: Selections near screen edges currently produce pills that extend beyond the visible area. This makes dimension readouts unreadable for edge-adjacent selections.
Output: Modified `SelectionOverlay.swift` with pill position clamping.
</objective>

<execution_context>
@/Users/haythem/.claude/get-shit-done/workflows/execute-plan.md
@/Users/haythem/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-selection-pill-clamping/04-RESEARCH.md
@swift/Ruler/Sources/Rendering/SelectionOverlay.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add screenSize property and clamp pill position in layoutPill()</name>
  <files>swift/Ruler/Sources/Rendering/SelectionOverlay.swift</files>
  <action>
Three changes to SelectionOverlay.swift:

1. **Add `screenSize` property** (stored at init):
   - Add `private let screenSize: CGSize` property declaration near the other stored properties (after `dimensionH`).
   - In `init(rect:parentLayer:scale:)`, capture `self.screenSize = parentLayer.bounds.size` BEFORE calling `setupLayers`. The parent layer is CrosshairView's layer, which fills the entire screen, so `bounds.size` equals the screen size in window-local coordinates.

2. **Add `clampMargin` constant**:
   - Add `private let clampMargin: CGFloat = 4` alongside the other pill layout constants (after `slideDistance`). This accounts for the pill's drop shadow extent: `shadowRadius=3` + `abs(shadowOffset.height)=1` = 4px maximum visual overflow.

3. **Add clamping to `layoutPill()`**:
   - Change `pillX` from `let` to `var`.
   - Replace the vertical flip threshold `if pillY < 8` with `if pillY < clampMargin` for consistency.
   - AFTER the existing above/below flip logic (line 274-276), add horizontal clamping:
     ```swift
     let maxX = screenSize.width - pillW - clampMargin
     pillX = min(max(pillX, clampMargin), max(clampMargin, maxX))
     ```
   - Then add vertical clamping:
     ```swift
     let maxY = screenSize.height - pillHeight - clampMargin
     pillY = min(max(pillY, clampMargin), max(clampMargin, maxY))
     ```
   - The inner `max(clampMargin, maxX/maxY)` guards against the impossible case where the pill is wider/taller than the screen minus margins (cannot happen in practice on macOS, but prevents a negative clamp range).
   - The clamping MUST come after the flip logic so that both the "below" and "above" positions get clamped.
   - Do NOT change anything else in layoutPill() -- the pillRect construction, frame assignments, and squircle path generation remain identical.
  </action>
  <verify>
Build succeeds: `cd /Users/haythem/Developer/design-ruler/swift/Ruler && swift build 2>&1 | tail -5`

Code review checklist (grep-verify):
- `screenSize` property exists: `grep "screenSize" swift/Ruler/Sources/Rendering/SelectionOverlay.swift`
- Clamping in layoutPill: `grep -n "clampMargin" swift/Ruler/Sources/Rendering/SelectionOverlay.swift`
- parentLayer.bounds.size captured in init: `grep "parentLayer.bounds.size" swift/Ruler/Sources/Rendering/SelectionOverlay.swift`
- No other files modified (single-file change)
  </verify>
  <done>
- `screenSize` stored from `parentLayer.bounds.size` at init time
- `clampMargin = 4` constant declared alongside other pill constants
- `layoutPill()` clamps `pillX` to `[clampMargin, screenWidth - pillW - clampMargin]`
- `layoutPill()` clamps `pillY` to `[clampMargin, screenHeight - pillHeight - clampMargin]`
- Vertical flip threshold uses `clampMargin` instead of hardcoded `8`
- Swift build succeeds with zero errors
  </done>
</task>

</tasks>

<verification>
After implementation, verify the full file compiles and the clamping logic is structurally correct:

1. `swift build` in the Ruler package succeeds
2. `layoutPill()` contains both horizontal and vertical clamping AFTER the flip logic
3. `screenSize` is initialized in `init` before `setupLayers` / `updateRect`
4. No other methods or files were modified beyond the three targeted changes
</verification>

<success_criteria>
- SelectionOverlay.swift compiles with screen-bounds clamping in layoutPill()
- Pill position is clamped on both axes with a 4px margin for shadow clearance
- The flip-above logic runs before clamping (correct ordering)
- Single file modified, ~10 lines of new code
</success_criteria>

<output>
After completion, create `.planning/phases/04-selection-pill-clamping/04-01-SUMMARY.md`
</output>
