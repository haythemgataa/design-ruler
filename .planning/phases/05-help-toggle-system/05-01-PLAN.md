---
phase: 05-help-toggle-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - swift/Ruler/Sources/RulerWindow.swift
  - swift/Ruler/Sources/Ruler.swift
autonomous: true

must_haves:
  truths:
    - "Pressing backspace dismisses the hint bar and briefly shows 'Press ? for help' before auto-fading"
    - "Pressing '?' after dismissal brings the hint bar back"
    - "Quitting and relaunching remembers the dismissed state (hint bar stays hidden on relaunch)"
    - "Launching with previously-dismissed hint bar shows 'Press ? for help' briefly on startup"
    - "The transient 'Press ? for help' message auto-fades after ~2.5s without user action"
  artifacts:
    - path: "swift/Ruler/Sources/RulerWindow.swift"
      provides: "Transient help label lifecycle, '?' key handler, backspace enhancement, launch-with-dismissed logic"
      contains: "transientBgLayer"
    - path: "swift/Ruler/Sources/Ruler.swift"
      provides: "Passes dismissed state to RulerWindow for launch transient message"
      contains: "hintBarDismissed"
  key_links:
    - from: "RulerWindow.keyDown"
      to: "showTransientHelp"
      via: "backspace handler completion block"
      pattern: "case 51.*showTransientHelp"
    - from: "RulerWindow.keyDown"
      to: "showHintBar"
      via: "event.characters == '?' check"
      pattern: "event\\.characters.*\\?"
    - from: "RulerWindow.setupViews"
      to: "showTransientHelp"
      via: "launch-with-dismissed path"
      pattern: "dismissed.*showTransientHelp"
    - from: "showTransientHelp"
      to: "fadeOutTransientHelp"
      via: "DispatchQueue.main.asyncAfter with generation counter"
      pattern: "transientGeneration"
---

<objective>
Add the help toggle system: backspace dismisses the hint bar and shows a transient "Press ? for help" message that auto-fades; pressing "?" re-enables the hint bar; dismissed state persists across sessions; launching with dismissed state shows the transient message.

Purpose: Users can dismiss the hint bar for a clean workspace without losing the ability to rediscover keyboard shortcuts.
Output: Modified RulerWindow.swift and Ruler.swift implementing the complete help toggle cycle.
</objective>

<execution_context>
@/Users/haythem/.claude/get-shit-done/workflows/execute-plan.md
@/Users/haythem/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-help-toggle-system/05-RESEARCH.md
@swift/Ruler/Sources/RulerWindow.swift
@swift/Ruler/Sources/Ruler.swift
@swift/Ruler/Sources/Rendering/HintBarView.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add transient help label and "?" key handler to RulerWindow</name>
  <files>swift/Ruler/Sources/RulerWindow.swift</files>
  <action>
Add the transient "Press ? for help" message system and "?" key re-enable to RulerWindow.swift. All changes are in this one file.

**1. Extract UserDefaults key constant** (top of class, private):
```swift
private let kHintBarDismissedKey = "com.raycast.design-ruler.hintBarDismissed"
```
Replace all 2 existing occurrences of the string literal `"com.raycast.design-ruler.hintBarDismissed"` with this constant.

**2. Add transient message properties** (alongside existing properties):
```swift
private var transientBgLayer: CAShapeLayer?
private var transientTextLayer: CATextLayer?
private var transientGeneration: Int = 0
private var hideHintBarPref: Bool = false   // Track the preference for re-add guard
```

**3. Add `showTransientHelp()` method:**
Create a method that builds and shows the transient "Press ? for help" label using CAShapeLayer (rounded rect background, dark semi-transparent) + CATextLayer (white text). Position at bottom center of screen, 20px margin (AppKit coords). Style: 16pt system font medium weight, -0.4 kern, CGColor(gray: 0, alpha: 0.7) background, cornerRadius 12, shadow matching the existing pill style. Both layers start at opacity 0. Add to `contentView!.layer!`. Animate fade-in over 0.3s using CATransaction. Then schedule auto-fade via `DispatchQueue.main.asyncAfter(deadline: .now() + 2.3)` — the closure captures the current `transientGeneration` and only calls `fadeOutTransientHelp()` if the generation still matches.

Increment `transientGeneration` at the start of `showTransientHelp()`.

**4. Add `fadeOutTransientHelp()` method:**
Increment `transientGeneration`. Animate both layers to opacity 0 over 0.5s using CATransaction with a completion block that calls `removeFromSuperlayer()` on both layers and nils the references.

**5. Add `showHintBar()` method** (for "?" key):
Guard: `hintBarView.superview == nil` (not already showing) AND `!hideHintBarPref` (preference didn't disable it). Clear any pressed keys on hintBarView state by calling `releaseKey` for all KeyID cases (prevents stuck key caps). Set `hintBarView.alphaValue = 0`. Call `hintBarView.configure(screenWidth:screenHeight:)` with `screenBounds.size`. Add `hintBarView` to `contentView!`. Call `hintBarView.updatePosition(cursorY:screenHeight:)` with current cursor position (use `NSEvent.mouseLocation` converted to window coords). Animate `alphaValue` to 1 over 0.3s via `NSAnimationContext.runAnimationGroup`. Remove the UserDefaults dismissed key. Call `fadeOutTransientHelp()` to dismiss any visible transient message.

**6. Store `hideHintBarPref` in `setupViews`:**
In `setupViews`, store the `hideHintBar` parameter to `self.hideHintBarPref` so the "?" handler knows whether the preference disabled it.

**7. Enhance the backspace handler (case 51):**
After the existing fade-out animation's completion handler removes the hint bar from superview and resets alphaValue to 1, add a call to `showTransientHelp()`. The enhanced completion handler should be:
```swift
completionHandler: {
    self.hintBarView.removeFromSuperview()
    self.hintBarView.alphaValue = 1  // Reset for potential re-add
    self.showTransientHelp()         // Show "Press ? for help"
}
```

**8. Add launch-with-dismissed transient message in `setupViews`:**
In the existing `if !hideHintBar && !dismissed` block, add an `else if !hideHintBar && dismissed` branch that calls `showTransientHelp()` after the contentView is set (the layers need a parent). Since `contentView` is set after this block, instead: add a `showTransientOnLaunch` bool flag. Set it to true in the else-if branch. After `contentView = containerView`, check the flag and call `showTransientHelp()`.

**9. Add "?" key detection in `keyDown`:**
AFTER the existing `switch Int(event.keyCode)` block (after the closing brace of the switch), add:
```swift
// Layout-independent "?" detection (Shift+/ on US, varies by layout)
if event.characters == "?" {
    showHintBar()
}
```
This must be outside/after the switch so it fires regardless of keyCode.

**Important implementation details:**
- Use `event.characters == "?"` NOT keyCode for "?" detection (keyboard layout independence)
- The transient message must use `contentView!.layer!` as parent, not the crosshairView layer
- Use `backingScaleFactor` for CATextLayer's `contentsScale` (Retina crisp text)
- The generation counter pattern prevents stale asyncAfter closures from firing after "?" restores the hint bar
  </action>
  <verify>
Build succeeds: `cd /Users/haythem/Developer/design-ruler/swift/Ruler && swift build 2>&1 | tail -5`

Verify key patterns exist in the file:
- `kHintBarDismissedKey` constant used (no raw string literals for that key)
- `transientGeneration` generation counter present
- `event.characters == "?"` for layout-independent detection
- `showTransientHelp()` called from both backspace completion and launch-with-dismissed
- `showHintBar()` method with guard and fadeOutTransientHelp call
  </verify>
  <done>
RulerWindow.swift compiles with: transient help label (CAShapeLayer + CATextLayer) with fade-in/auto-fade/fade-out lifecycle, "?" key handler that re-enables hint bar, enhanced backspace handler that shows transient message after dismissal, and launch-with-dismissed path that shows transient message on startup. Generation counter prevents stale auto-fade callbacks.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update Ruler.swift UserDefaults key and verify full build</name>
  <files>swift/Ruler/Sources/Ruler.swift</files>
  <action>
Update Ruler.swift to use the same UserDefaults key constant pattern and verify the full extension builds.

**1. Extract or reference the UserDefaults key:**
In `Ruler.run()`, the string `"com.raycast.design-ruler.hintBarDismissed"` appears once (line 34). Since Swift doesn't allow cross-class `private let` constants, define a file-level constant at the top of Ruler.swift:
```swift
private let kHintBarDismissedKey = "com.raycast.design-ruler.hintBarDismissed"
```
Replace the string literal in `run()` with `kHintBarDismissedKey`.

Note: Both files will have their own `private let kHintBarDismissedKey` — this is intentional. A shared constant would require a separate file or internal access, which is overkill for a single string used in 2 files. The duplication is the lesser evil vs. unnecessary coupling.

**2. Run full Raycast build:**
```bash
cd /Users/haythem/Developer/design-ruler && rm -rf swift/Ruler/.raycast-swift-build && ray build
```
This tests the full Raycast compilation pipeline (not just `swift build`).
  </action>
  <verify>
`ray build` succeeds with no errors.

Grep confirms no remaining raw UserDefaults key string literals:
```bash
grep -rn '"com.raycast.design-ruler.hintBarDismissed"' swift/Ruler/Sources/ | grep -v 'kHintBarDismissedKey ='
```
Should return empty (all usages go through the constant, except the constant definitions themselves).
  </verify>
  <done>
Both Ruler.swift and RulerWindow.swift use `kHintBarDismissedKey` constants instead of raw string literals. Full Raycast build (`ray build`) passes. The complete help toggle system is wired: backspace dismisses + shows transient, "?" re-enables, state persists via UserDefaults, launch-with-dismissed shows transient.
  </done>
</task>

</tasks>

<verification>
After both tasks complete, verify the phase success criteria:

1. **Backspace dismisses hint bar + shows transient message**: The backspace handler (case 51) fades out the hint bar, then calls `showTransientHelp()` in the completion block. UserDefaults records the dismissed state.

2. **"?" re-enables hint bar**: `event.characters == "?"` check after the keyCode switch calls `showHintBar()`, which adds the hint bar back with fade-in, clears UserDefaults, and dismisses any visible transient message.

3. **Session persistence**: UserDefaults `kHintBarDismissedKey` is set on backspace, removed on "?", and read in `setupViews` to skip adding the hint bar on launch.

4. **Launch-with-dismissed shows transient**: `setupViews` detects `!hideHintBar && dismissed` and calls `showTransientHelp()` to show the brief "Press ? for help" message.

5. **Auto-fade**: `showTransientHelp()` schedules `fadeOutTransientHelp()` via `DispatchQueue.main.asyncAfter(deadline: .now() + 2.3)` with generation counter guard. Fade-out animates opacity to 0 over 0.5s.

Build verification:
```bash
cd /Users/haythem/Developer/design-ruler && ray build
```
</verification>

<success_criteria>
- `ray build` passes with no errors
- No raw `"com.raycast.design-ruler.hintBarDismissed"` string literals remain (all via constants)
- RulerWindow.swift contains: `showTransientHelp()`, `fadeOutTransientHelp()`, `showHintBar()`, `transientGeneration`, `event.characters == "?"`
- Transient message uses CAShapeLayer + CATextLayer (not NSView/NSTextField)
- Generation counter prevents stale asyncAfter from firing after "?" restores hint bar
</success_criteria>

<output>
After completion, create `.planning/phases/05-help-toggle-system/05-01-SUMMARY.md`
</output>
