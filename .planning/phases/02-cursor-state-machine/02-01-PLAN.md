---
phase: 02-cursor-state-machine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - swift/Ruler/Sources/Cursor/CursorManager.swift
  - swift/Ruler/Sources/Ruler.swift
  - swift/Ruler/Sources/RulerWindow.swift
  - swift/Ruler/Sources/Rendering/CrosshairView.swift
autonomous: true

must_haves:
  truths:
    - "All NSCursor push/pop/hide/unhide calls go through CursorManager (no direct NSCursor manipulation outside CursorManager and resetCursorRects)"
    - "Pressing ESC during any cursor state (hidden, crosshair, pointing hand) restores cursor to normal system arrow"
    - "Force-killing the process via SIGTERM (Raycast shutdown) restores cursor visibility"
    - "Cursor is never stuck hidden or stuck as wrong type after exiting the overlay"
  artifacts:
    - path: "swift/Ruler/Sources/Cursor/CursorManager.swift"
      provides: "Centralized cursor state machine with explicit state enum and balanced hide/push counters"
      contains: "final class CursorManager"
    - path: "swift/Ruler/Sources/Ruler.swift"
      provides: "SIGTERM handler via DispatchSource and CursorManager.restore() on all exit paths"
      contains: "DispatchSource.makeSignalSource"
    - path: "swift/Ruler/Sources/RulerWindow.swift"
      provides: "All cursor transitions routed through CursorManager"
      contains: "CursorManager.shared"
    - path: "swift/Ruler/Sources/Rendering/CrosshairView.swift"
      provides: "NSCursor.hide() moved to CursorManager; resetCursorRects kept as-is"
      contains: "CursorManager.shared.transitionToHidden()"
  key_links:
    - from: "swift/Ruler/Sources/Ruler.swift"
      to: "swift/Ruler/Sources/Cursor/CursorManager.swift"
      via: "CursorManager.shared.restore() in handleExit()"
      pattern: "CursorManager\\.shared\\.restore"
    - from: "swift/Ruler/Sources/RulerWindow.swift"
      to: "swift/Ruler/Sources/Cursor/CursorManager.swift"
      via: "CursorManager transition calls replacing 15 direct NSCursor calls"
      pattern: "CursorManager\\.shared\\.(transitionTo|transitionBack)"
    - from: "swift/Ruler/Sources/Rendering/CrosshairView.swift"
      to: "swift/Ruler/Sources/Cursor/CursorManager.swift"
      via: "CursorManager.shared.transitionToHidden() replacing NSCursor.hide() in hideSystemCrosshair()"
      pattern: "CursorManager\\.shared\\.transitionToHidden"
    - from: "swift/Ruler/Sources/Ruler.swift"
      to: "DispatchSource SIGTERM handler"
      via: "signal(SIGTERM, SIG_IGN) + DispatchSource.makeSignalSource calling handleExit()"
      pattern: "makeSignalSource.*SIGTERM"
---

<objective>
Centralize all NSCursor management into a single CursorManager class with explicit state tracking, and add SIGTERM signal handling for graceful cursor restoration on process termination.

Purpose: Eliminate cursor-stuck bugs caused by scattered, unbalanced NSCursor push/pop/hide/unhide calls across 3 files (18 call sites). Guarantee the cursor is always correctly restored regardless of exit path (ESC, SIGTERM, inactivity timeout).

Output: CursorManager.swift (new), updated Ruler.swift, RulerWindow.swift, and CrosshairView.swift with all cursor manipulation routed through CursorManager.
</objective>

<execution_context>
@/Users/haythem/.claude/get-shit-done/workflows/execute-plan.md
@/Users/haythem/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-cursor-state-machine/02-RESEARCH.md

Source files to modify:
@swift/Ruler/Sources/Ruler.swift
@swift/Ruler/Sources/RulerWindow.swift
@swift/Ruler/Sources/Rendering/CrosshairView.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CursorManager and wire SIGTERM handler</name>
  <files>
    swift/Ruler/Sources/Cursor/CursorManager.swift
    swift/Ruler/Sources/Ruler.swift
  </files>
  <action>
**Create `swift/Ruler/Sources/Cursor/CursorManager.swift`:**

Create a new `Cursor/` directory under `Sources/` and add `CursorManager.swift` with:

1. A `final class CursorManager` with `static let shared = CursorManager()` and `private init()`.

2. A `State` enum with cases: `systemCrosshair` (launch state), `hidden` (after first mouse move), `pointingHand` (hovering selection), `crosshairDrag` (during drag).

3. A `private(set) var state: State = .systemCrosshair` property.

4. Private counters: `hideCount: Int = 0` and `pushCount: Int = 0` to track our own NSCursor hide/push calls for balanced cleanup.

5. Transition methods (each with a guard on expected source state):

   - `transitionToHidden()`: Guard `state == .systemCrosshair`. Call `NSCursor.hide()`, increment `hideCount`, set state to `.hidden`. This is called on first mouse move after CrosshairView invalidates cursor rects.

   - `transitionToPointingHand()`: Guard `state == .hidden`. Call `NSCursor.pointingHand.push()`, increment `pushCount`. Call `NSCursor.unhide()`, decrement `hideCount` (use `max(hideCount - 1, 0)`). Set state to `.pointingHand`.

   - `transitionToCrosshairDrag()`: Guard `state == .hidden`. Call `NSCursor.crosshair.push()`, increment `pushCount`. Call `NSCursor.unhide()`, decrement `hideCount` (use `max(hideCount - 1, 0)`). Set state to `.crosshairDrag`.

   - `transitionBackToHidden()`: Switch on state. For `.pointingHand` and `.crosshairDrag`: call `NSCursor.pop()`, decrement `pushCount` (use `max(pushCount - 1, 0)`), call `NSCursor.hide()`, increment `hideCount`, set state to `.hidden`. For all other states: no-op.

6. `restore()` method — unconditional cleanup for all exit paths:
   - Loop `pushCount` times calling `NSCursor.pop()`, then set `pushCount = 0`.
   - Loop `hideCount` times calling `NSCursor.unhide()`, then set `hideCount = 0`.
   - Set `state = .systemCrosshair`.

7. `reset()` method — delegates to `restore()`. Used for multi-monitor window re-setup.

Import only `AppKit`.

**Modify `swift/Ruler/Sources/Ruler.swift`:**

1. Add a `private var sigTermSource: DispatchSourceSignal?` property to the `Ruler` class.

2. Add a `private func setupSignalHandler()` method:
   - Call `signal(SIGTERM, SIG_IGN)` to ignore default SIGTERM behavior.
   - Create a `DispatchSource.makeSignalSource(signal: SIGTERM, queue: .main)`.
   - Set the event handler to call `self?.handleExit()` (use `[weak self]`).
   - Call `source.resume()`.
   - Store as `sigTermSource = source` (must retain or it gets deallocated).

3. Call `setupSignalHandler()` in `run()` — place it right before `resetInactivityTimer()` (just before `app.run()`).

4. Replace the body of `handleExit()`:
   - REMOVE the `if firstMoveReceived { NSCursor.unhide() }` block.
   - ADD `CursorManager.shared.restore()` as the first line.
   - Keep the `for window in windows { window.close() }` and `NSApp.terminate(nil)` lines unchanged.

Do NOT change the `firstMoveReceived` property or `handleFirstMove()` — they are still used for multi-monitor coordination via the `onFirstMove` callback. The `firstMoveReceived` boolean tracks whether ANY window has received a first move (for `activateWindow`), while CursorManager tracks the actual cursor state independently.
  </action>
  <verify>
Run `swift build` from the `swift/Ruler/` directory. The build must succeed with zero errors. Verify with:
```bash
cd swift/Ruler && swift build 2>&1 | tail -20
```

Then verify CursorManager exists and has the expected structure:
```bash
grep -n "func transition\|func restore\|enum State\|case " swift/Ruler/Sources/Cursor/CursorManager.swift
```

Verify no direct NSCursor calls remain in Ruler.swift (except through CursorManager):
```bash
grep -n "NSCursor" swift/Ruler/Sources/Ruler.swift
```
This should return zero matches.

Verify SIGTERM handler is wired:
```bash
grep -n "SIGTERM\|sigTermSource\|setupSignalHandler" swift/Ruler/Sources/Ruler.swift
```
  </verify>
  <done>
CursorManager.swift exists with State enum (4 cases), 4 transition methods, restore(), and reset(). Ruler.swift calls CursorManager.shared.restore() in handleExit() instead of direct NSCursor.unhide(). SIGTERM DispatchSource is wired and retained. Build succeeds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate all NSCursor call sites in RulerWindow and CrosshairView</name>
  <files>
    swift/Ruler/Sources/RulerWindow.swift
    swift/Ruler/Sources/Rendering/CrosshairView.swift
  </files>
  <action>
**Migrate `swift/Ruler/Sources/RulerWindow.swift` (15 NSCursor calls):**

All migrations follow the research inventory. Replace pairs of NSCursor calls with single CursorManager transitions:

1. **`deactivate()` method** (~lines 122-135):
   - Replace `NSCursor.pop()` + `NSCursor.hide()` in the `isHoveringSelection` block with `CursorManager.shared.transitionBackToHidden()`.
   - Replace `NSCursor.pop(); NSCursor.hide()` in the `isDragging` block with `CursorManager.shared.transitionBackToHidden()`.
   - REMOVE the `if hasReceivedFirstMove` guard around the drag cursor cleanup — CursorManager's guard on state handles this correctly (if state is not `.crosshairDrag`, `transitionBackToHidden()` is a no-op).

2. **`mouseMoved()` method** (~lines 199-214):
   - Replace `NSCursor.pointingHand.push()` + `NSCursor.unhide()` (entering hover) with `CursorManager.shared.transitionToPointingHand()`.
   - Replace `NSCursor.pop()` + `NSCursor.hide()` (leaving hover) with `CursorManager.shared.transitionBackToHidden()`.

3. **`mouseDown()` method** (~lines 228-267):
   - **Stale drag cleanup** (~line 231): Replace `NSCursor.pop(); NSCursor.hide()` (guarded by `if hasReceivedFirstMove`) with `CursorManager.shared.transitionBackToHidden()`. Remove the `hasReceivedFirstMove` guard.
   - **Click-to-remove selection** (~lines 239-240): Replace `NSCursor.pop()` + `NSCursor.hide()` with `CursorManager.shared.transitionBackToHidden()`.
   - **Start drag from hover** (~line 258): The `NSCursor.pop()` that removes pointing hand before drag — this is now handled by calling `CursorManager.shared.transitionBackToHidden()` first, then starting the drag.
   - **Start drag cursor** (~lines 265-266): Replace `NSCursor.crosshair.push()` + `NSCursor.unhide()` (guarded by `if hasReceivedFirstMove`) with `CursorManager.shared.transitionToCrosshairDrag()`. Remove the `hasReceivedFirstMove` guard — CursorManager's guard on `.hidden` state handles this (if cursor is still in `.systemCrosshair` state because no mouse move happened, CursorManager will correctly reject the transition).

   The full `mouseDown()` drag-start flow after migration should be:
   ```swift
   // Start drag
   isDragging = true
   if isHoveringSelection {
       isHoveringSelection = false
       CursorManager.shared.transitionBackToHidden()
   }
   crosshairView.hideForDrag()
   selectionManager.startDrag(at: windowPoint)
   CursorManager.shared.transitionToCrosshairDrag()
   ```

4. **`mouseUp()` method** (~lines 297-298):
   - Replace `NSCursor.pop()` + `NSCursor.hide()` (guarded by `if hasReceivedFirstMove`) with `CursorManager.shared.transitionBackToHidden()`. Remove the `hasReceivedFirstMove` guard.

**Migrate `swift/Ruler/Sources/Rendering/CrosshairView.swift` (1 NSCursor call to migrate):**

1. **`hideSystemCrosshair()` method** (~line 117):
   - KEEP `showSystemCrosshair = false` and `window?.invalidateCursorRects(for: self)` — these are cursor-rect operations that stay in CrosshairView (per research: "resetCursorRects exception").
   - REPLACE `NSCursor.hide()` with `CursorManager.shared.transitionToHidden()`.

2. **`resetCursorRects()` override** (~line 81-84):
   - KEEP exactly as-is. The `addCursorRect(bounds, cursor: .crosshair)` is an AppKit framework callback, not a CursorManager concern.

**After all migrations, verify zero direct NSCursor calls remain outside CursorManager:**

The ONLY place `NSCursor` should appear in non-CursorManager files is:
- `CrosshairView.swift` line ~83: `addCursorRect(bounds, cursor: .crosshair)` in `resetCursorRects()` — this is allowed (AppKit framework callback).

No other file should contain `NSCursor.hide`, `NSCursor.unhide`, `NSCursor.pop`, `NSCursor.push`, `NSCursor.pointingHand`, or `NSCursor.crosshair` (except as `.crosshair` inside `addCursorRect`).
  </action>
  <verify>
Run `swift build` from the `swift/Ruler/` directory. The build must succeed with zero errors:
```bash
cd swift/Ruler && swift build 2>&1 | tail -20
```

Verify zero direct NSCursor calls outside CursorManager (except the allowed resetCursorRects):
```bash
grep -rn "NSCursor" swift/Ruler/Sources/ --include="*.swift" | grep -v "CursorManager.swift" | grep -v "addCursorRect"
```
This should return zero matches.

Verify CursorManager is actually used in migrated files:
```bash
grep -rn "CursorManager.shared" swift/Ruler/Sources/ --include="*.swift" | grep -v "CursorManager.swift"
```
This should show calls in Ruler.swift, RulerWindow.swift, and CrosshairView.swift.

Then do a full Raycast build to catch any deployment issues:
```bash
cd /Users/haythem/Developer/design-ruler && rm -rf swift/Ruler/.raycast-swift-build && ray build 2>&1 | tail -20
```
  </verify>
  <done>
All 15 NSCursor calls in RulerWindow.swift are replaced with CursorManager transitions. The 1 migratable NSCursor call in CrosshairView.swift is replaced. The only remaining NSCursor reference outside CursorManager is `addCursorRect(bounds, cursor: .crosshair)` in resetCursorRects(). Build succeeds (both swift build and ray build).
  </done>
</task>

</tasks>

<verification>
1. **Build verification:** `swift build` and `ray build` both succeed with zero errors.
2. **Call site audit:** `grep -rn "NSCursor" swift/Ruler/Sources/ --include="*.swift" | grep -v "CursorManager.swift" | grep -v "addCursorRect"` returns zero matches.
3. **CursorManager usage:** `grep -rn "CursorManager.shared" swift/Ruler/Sources/ --include="*.swift"` shows calls in Ruler.swift (restore), RulerWindow.swift (transitions), and CrosshairView.swift (transitionToHidden).
4. **SIGTERM wiring:** `grep -n "SIGTERM\|sigTermSource" swift/Ruler/Sources/Ruler.swift` shows signal handler setup and retained source.
5. **State machine completeness:** CursorManager has 4 enum cases, 4 transition methods, restore(), and reset().
</verification>

<success_criteria>
- CursorManager.swift exists with State enum (systemCrosshair, hidden, pointingHand, crosshairDrag), 4 transitions, restore(), reset()
- Zero direct NSCursor push/pop/hide/unhide calls outside CursorManager (except addCursorRect in resetCursorRects)
- SIGTERM DispatchSource handler wired in Ruler.swift, calling handleExit() which calls CursorManager.shared.restore()
- Both `swift build` and `ray build` succeed
</success_criteria>

<output>
After completion, create `.planning/phases/02-cursor-state-machine/02-01-SUMMARY.md`
</output>
