---
phase: 03-snap-failure-shake
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - swift/Ruler/Sources/Rendering/SelectionOverlay.swift
  - swift/Ruler/Sources/Rendering/SelectionManager.swift
autonomous: true

must_haves:
  truths:
    - "When drag-to-select fails to snap to edges, the selection overlay shakes horizontally before fading out"
    - "The shake follows macOS convention (login rejection idiom -- damped horizontal oscillation)"
    - "The shake animation does not cause the overlay to jump to a wrong position after completing"
    - "Successful snaps are unaffected (no shake)"
    - "Tiny accidental drags (< 4px) are still removed instantly without shake"
  artifacts:
    - path: "swift/Ruler/Sources/Rendering/SelectionOverlay.swift"
      provides: "shakeAndRemove() method with additive CAKeyframeAnimation"
      contains: "func shakeAndRemove"
    - path: "swift/Ruler/Sources/Rendering/SelectionManager.swift"
      provides: "Snap failure calls shakeAndRemove instead of remove"
      contains: "shakeAndRemove"
  key_links:
    - from: "swift/Ruler/Sources/Rendering/SelectionManager.swift"
      to: "swift/Ruler/Sources/Rendering/SelectionOverlay.swift"
      via: "sel.shakeAndRemove() call in endDrag() snap failure branch"
      pattern: "shakeAndRemove"
    - from: "SelectionOverlay.shakeAndRemove()"
      to: "SelectionOverlay.remove(animated:)"
      via: "CATransaction.setCompletionBlock chains shake into existing fade-out"
      pattern: "setCompletionBlock.*remove"
---

<objective>
Add a horizontal shake animation (macOS login rejection idiom) to the selection overlay when edge snap fails, providing clear visual feedback before the overlay fades out.

Purpose: Users currently get no feedback when a drag-to-select fails to snap -- the overlay just fades away silently. The shake communicates "that didn't work" using a universally understood macOS idiom.
Output: Two modified Swift files; shake + fade-out animation chain on snap failure.
</objective>

<execution_context>
@/Users/haythem/.claude/get-shit-done/workflows/execute-plan.md
@/Users/haythem/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-snap-failure-shake/03-RESEARCH.md
@swift/Ruler/Sources/Rendering/SelectionOverlay.swift
@swift/Ruler/Sources/Rendering/SelectionManager.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add shakeAndRemove() to SelectionOverlay</name>
  <files>swift/Ruler/Sources/Rendering/SelectionOverlay.swift</files>
  <action>
Add a `shakeAndRemove()` method to `SelectionOverlay`, placed just above the existing `remove(animated:)` method (around line 190). The method:

1. Creates a single `CAKeyframeAnimation(keyPath: "position.x")` with:
   - `values`: `[0, -10, 10, -6, 6, -2, 2, 0]` (damped oscillation)
   - `keyTimes`: `[0, 0.1, 0.25, 0.4, 0.55, 0.7, 0.85, 1.0]` (as NSNumber array)
   - `duration`: `0.4`
   - `isAdditive = true` (CRITICAL: values are relative offsets, not absolute positions)

2. Collects all 4 layers: `[rectLayer, fillLayer, pillBgLayer, pillTextLayer]`

3. Wraps in `CATransaction.begin()/commit()` with `setCompletionBlock` that calls `self?.remove(animated: true)` (chains into the existing 0.15s fade-out)

4. Adds the SAME animation object to all 4 layers via `layer.add(shake, forKey: "shake")` -- Core Animation allows sharing one animation object across multiple layers

Use `[weak self]` in the completion block to avoid retain cycles.

Do NOT:
- Modify model layer position values (the additive animation handles offsets)
- Use `fillMode` or `isRemovedOnCompletion = false` (anti-pattern; final additive value is 0 so removal changes nothing)
- Touch any other method in SelectionOverlay
  </action>
  <verify>
`cd /Users/haythem/Developer/design-ruler/swift/Ruler && swift build 2>&1 | tail -5` compiles without errors. Grep for `func shakeAndRemove` in SelectionOverlay.swift confirms the method exists.
  </verify>
  <done>SelectionOverlay has a shakeAndRemove() method that applies a damped horizontal shake animation to all 4 layers, then chains into the existing fade-out removal via CATransaction completion block.</done>
</task>

<task type="auto">
  <name>Task 2: Wire shakeAndRemove into snap failure path</name>
  <files>swift/Ruler/Sources/Rendering/SelectionManager.swift</files>
  <action>
In `SelectionManager.endDrag(at:screenBounds:)`, find the `else` branch (line 56-58) where `edgeDetector.snapSelection()` returns `nil`. Change:

```swift
sel.remove(animated: true)
```

to:

```swift
sel.shakeAndRemove()
```

This is a single-line change. The rest of the method remains identical:
- The minimum drag distance early return (line 44-47) still calls `sel.remove(animated: false)` -- tiny drags do NOT shake.
- The successful snap branch (line 50-54) still calls `sel.animateSnap(to:w:h:)` -- successful snaps are unaffected.
- The method still returns `false` after the shake path.

Do NOT change any other code in SelectionManager.
  </action>
  <verify>
`cd /Users/haythem/Developer/design-ruler/swift/Ruler && swift build 2>&1 | tail -5` compiles without errors. Grep for `shakeAndRemove` in SelectionManager.swift confirms the call site exists. Grep for `remove(animated: true)` in the endDrag method confirms it no longer appears in the snap failure branch (it still appears in removeSelection and clearAll methods).
  </verify>
  <done>SelectionManager.endDrag() calls shakeAndRemove() on snap failure. Successful snaps and tiny drags are unaffected.</done>
</task>

</tasks>

<verification>
1. `cd /Users/haythem/Developer/design-ruler/swift/Ruler && swift build` -- must compile cleanly
2. `ray build -e design-ruler` -- Raycast extension builds successfully (if ray CLI available)
3. Code review: `shakeAndRemove()` uses `isAdditive = true` (no position jumps), chains via `CATransaction.setCompletionBlock` (no overlap), applies to all 4 layers (no visual disconnect)
4. Code review: Only the snap failure branch in `endDrag()` calls `shakeAndRemove()`; minimum drag guard and successful snap paths are untouched
</verification>

<success_criteria>
- SelectionOverlay.shakeAndRemove() exists and compiles
- SelectionManager.endDrag() calls shakeAndRemove() on snap failure (not remove(animated:))
- Tiny drags (< 4px) still use remove(animated: false) -- no shake
- Successful snaps still use animateSnap -- no shake
- Swift build succeeds with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-snap-failure-shake/03-01-SUMMARY.md`
</output>
