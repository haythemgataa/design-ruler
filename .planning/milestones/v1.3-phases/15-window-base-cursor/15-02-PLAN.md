---
phase: 15-window-base-cursor
plan: 02
type: execute
wave: 2
depends_on: ["15-01"]
files_modified:
  - swift/Ruler/Sources/RulerWindow.swift
  - swift/Ruler/Sources/AlignmentGuides/AlignmentGuidesWindow.swift
autonomous: true

must_haves:
  truths:
    - "RulerWindow subclasses OverlayWindow and no longer duplicates window config, tracking, throttle, first-move, hint bar, or ESC handling"
    - "AlignmentGuidesWindow subclasses OverlayWindow and no longer duplicates window config, tracking, throttle, first-move, hint bar, or ESC handling"
    - "AlignmentGuidesWindow uses CursorManager resize states instead of managing resize cursors independently"
    - "Both commands exhibit identical runtime behavior to before the refactor"
  artifacts:
    - path: "swift/Ruler/Sources/RulerWindow.swift"
      provides: "Thin OverlayWindow subclass with only design-ruler-specific logic"
      contains: "class RulerWindow: OverlayWindow"
    - path: "swift/Ruler/Sources/AlignmentGuides/AlignmentGuidesWindow.swift"
      provides: "Thin OverlayWindow subclass with only alignment-guides-specific logic"
      contains: "class AlignmentGuidesWindow: OverlayWindow"
  key_links:
    - from: "swift/Ruler/Sources/RulerWindow.swift"
      to: "swift/Ruler/Sources/Utilities/OverlayWindow.swift"
      via: "subclasses OverlayWindow, calls configureOverlay, setupTrackingArea, setupHintBar"
      pattern: "OverlayWindow\\.configureOverlay"
    - from: "swift/Ruler/Sources/AlignmentGuides/AlignmentGuidesWindow.swift"
      to: "swift/Ruler/Sources/Cursor/CursorManager.swift"
      via: "uses transitionToResize/transitionToPointingHandFromResize instead of local cursor management"
      pattern: "CursorManager\\.shared\\.transitionToResize"
---

<objective>
Refactor RulerWindow and AlignmentGuidesWindow to subclass OverlayWindow, eliminating all duplicated code and wiring AlignmentGuidesWindow to CursorManager's resize states.

Purpose: Completes the window base extraction — both windows become thin subclasses with only command-specific logic, and cursor management is fully centralized.

Output: Refactored RulerWindow.swift + AlignmentGuidesWindow.swift.
</objective>

<execution_context>
@/Users/haythem/.claude/get-shit-done/workflows/execute-plan.md
@/Users/haythem/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/15-window-base-cursor/15-01-SUMMARY.md
@swift/Ruler/Sources/RulerWindow.swift
@swift/Ruler/Sources/AlignmentGuides/AlignmentGuidesWindow.swift
@swift/Ruler/Sources/Utilities/OverlayWindow.swift
@swift/Ruler/Sources/Cursor/CursorManager.swift
@swift/Ruler/Sources/Utilities/OverlayCoordinator.swift
@swift/Ruler/Sources/Ruler.swift
@swift/Ruler/Sources/AlignmentGuides/AlignmentGuides.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor RulerWindow to subclass OverlayWindow</name>
  <files>swift/Ruler/Sources/RulerWindow.swift</files>
  <action>
Change `RulerWindow` from `NSWindow, OverlayWindowProtocol` to `OverlayWindow`. Remove everything the base now provides.

**Class declaration:**
```swift
final class RulerWindow: OverlayWindow {
```

Remove `OverlayWindowProtocol` conformance — inherited from OverlayWindow.

**Keep these subclass-specific properties:**
- `private var edgeDetector: EdgeDetector!`
- `private var crosshairView: CrosshairView!`
- `private var selectionManager: SelectionManager!`
- `private var isDragging = false`
- `private var isHoveringSelection = false`

**Remove these (now in base):**
- `private(set) var targetScreen: NSScreen!` — inherited
- `private var hintBarView: HintBarView!` — inherited
- `private var screenBounds: CGRect = .zero` — inherited
- `private var lastMoveTime: Double = 0` — inherited
- `private var hasReceivedFirstMove = false` — inherited

**Callbacks — keep only the typed one:**
- `var onActivate: ((RulerWindow) -> Void)?` — subclass-specific (typed)
- Remove `onRequestExit`, `onFirstMove`, `onActivity` — inherited from base

**Refactor create() factory:**
```swift
static func create(for screen: NSScreen, edgeDetector: EdgeDetector, hideHintBar: Bool, screenshot: CGImage? = nil) -> RulerWindow {
    let window = RulerWindow(
        contentRect: NSRect(origin: .zero, size: screen.frame.size),
        styleMask: .borderless,
        backing: .buffered,
        defer: false,
        screen: screen
    )
    OverlayWindow.configureOverlay(window, for: screen)
    window.edgeDetector = edgeDetector
    window.setupViews(screenFrame: screen.frame, edgeDetector: edgeDetector, hideHintBar: hideHintBar, screenshot: screenshot)
    window.setupTrackingArea()
    return window
}
```

**Refactor setupViews** — use base's setupHintBar helper:
```swift
private func setupViews(screenFrame: CGRect, edgeDetector: EdgeDetector, hideHintBar: Bool, screenshot: CGImage? = nil) {
    let size = screenFrame.size
    let containerView = NSView(frame: NSRect(origin: .zero, size: size))

    let cv = CrosshairView(frame: NSRect(origin: .zero, size: size))
    cv.screenFrame = screenFrame
    self.crosshairView = cv
    containerView.addSubview(cv)

    let scale = backingScaleFactor
    self.selectionManager = SelectionManager(
        parentLayer: cv.layer!,
        edgeDetector: edgeDetector,
        scale: scale
    )

    contentView = containerView

    // Use base's shared hint bar setup (mode defaults to .inspect)
    setupHintBar(mode: .inspect, screenSize: size, screenshot: screenshot, hideHintBar: hideHintBar, container: containerView)
}
```

**Override handleActivation():**
```swift
override func handleActivation() {
    onActivate?(self)
}
```

**Remove collapseHintBar()** — inherited from base.

**Remove mouseEntered** — inherited from base.

**Remove canBecomeKey/canBecomeMain** — inherited from base.

**Remove setupTrackingArea()** — inherited from base.

**Override showInitialState():**
Keep existing implementation but use inherited `screenBounds` and `hintBarView`:
```swift
override func showInitialState() {
    let mouseLocation = NSEvent.mouseLocation
    let windowPoint = NSPoint(
        x: mouseLocation.x - screenBounds.origin.x,
        y: mouseLocation.y - screenBounds.origin.y
    )
    crosshairView.showInitialPill(at: windowPoint)
    hintBarEntrance()
}
```

**Override handleMouseMoved(to:):**
Extract the body of the current `mouseMoved` MINUS the throttle, first-move, and hint bar positioning (base handles those):
```swift
override func handleMouseMoved(to windowPoint: NSPoint) {
    let appKitScreenPoint = NSPoint(
        x: screenBounds.origin.x + windowPoint.x,
        y: screenBounds.origin.y + windowPoint.y
    )

    guard let edges = edgeDetector.onMouseMoved(at: appKitScreenPoint) else { return }

    // Selection hover state
    if selectionManager.hasSelections, let _ = selectionManager.hitTest(windowPoint) {
        if !isHoveringSelection {
            isHoveringSelection = true
            crosshairView.hideForDrag()
            CursorManager.shared.transitionToPointingHand()
        }
        selectionManager.updateHover(at: windowPoint)
        return
    } else if isHoveringSelection {
        isHoveringSelection = false
        crosshairView.showAfterDrag()
        CursorManager.shared.transitionBackToHidden()
        selectionManager.updateHover(at: windowPoint)
    }

    crosshairView.update(cursor: windowPoint, edges: edges)
}
```

Note: first-move detection in base calls `onFirstMove` which triggers `crosshairView.hideSystemCrosshair()` via the callback wired in Ruler.swift's wireCallbacks. Wait — actually the current code calls `crosshairView.hideSystemCrosshair()` directly in mouseMoved. The base's first-move detection fires `onFirstMove?()` which goes to the coordinator. But the coordinator's `handleFirstMove()` only handles hint bar collapse, not `hideSystemCrosshair()`.

We need to handle this. The base fires `onFirstMove?()` on first move. In the current RulerWindow, first move also calls `crosshairView.hideSystemCrosshair()`. We have two options:
1. Add a `handleFirstMoveInWindow()` hook called by the base before `onFirstMove?()`
2. Check `hasReceivedFirstMove` at the start of `handleMouseMoved` (but base already set it to true)

Best approach: override a hook method. Add to OverlayWindow base a method `didReceiveFirstMove()` that is called right after setting `hasReceivedFirstMove = true` and before `onFirstMove?()`. RulerWindow overrides it to call `crosshairView.hideSystemCrosshair()`.

Actually wait — re-reading the base mouseMoved: the base sets `hasReceivedFirstMove = true` then calls `onFirstMove?()`. The RulerWindow currently does:
1. `hasReceivedFirstMove = true`
2. `crosshairView.hideSystemCrosshair()`
3. `onFirstMove?()`

So the `hideSystemCrosshair()` call needs to happen between 1 and 3, or can happen at the start of `handleMouseMoved(to:)` by checking a flag. But since `handleMouseMoved` is called AFTER onFirstMove, we need a pre-hook.

SOLUTION: In the base's mouseMoved, call an overridable `willHandleFirstMove()` method BEFORE `onFirstMove?()`:
```swift
if !hasReceivedFirstMove {
    hasReceivedFirstMove = true
    willHandleFirstMove()
    onFirstMove?()
}
```

RulerWindow overrides:
```swift
override func willHandleFirstMove() {
    crosshairView.hideSystemCrosshair()
}
```

**IMPORTANT:** This means OverlayWindow.swift (from Plan 01) needs the `willHandleFirstMove()` hook added. Update the base's mouseMoved to include it. The Plan 01 task action describes the base class code — the executor must include `willHandleFirstMove()` in the mouseMoved sequence.

Actually, since Plan 01 hasn't been executed yet, we can simply note that this hook must be present. But for correctness, let me adjust: Plan 01's mouseMoved implementation should include:
```swift
if !hasReceivedFirstMove {
    hasReceivedFirstMove = true
    willHandleFirstMove()
    onFirstMove?()
}
```
And add a default no-op: `func willHandleFirstMove() {}`

The executor of Plan 01 will read this plan context and include it. But to be safe, if the executor misses it, this task should verify the hook exists and add it if missing.

**Keep sendEvent** — subclass-specific (RulerWindow intercepts mouse events):
```swift
override func sendEvent(_ event: NSEvent) {
    switch event.type {
    case .leftMouseDown:  mouseDown(with: event)
    case .leftMouseDragged: mouseDragged(with: event)
    case .leftMouseUp:    mouseUp(with: event)
    default: super.sendEvent(event)
    }
}
```

**Keep mouseDown, mouseDragged, mouseUp** — subclass-specific (drag lifecycle).

**Override handleKeyDown** for arrow keys:
```swift
override func handleKeyDown(with event: NSEvent) {
    let shift = event.modifierFlags.contains(.shift)
    let hintVisible = hintBarView.superview != nil

    switch Int(event.keyCode) {
    case 123: // Left arrow
        if !event.isARepeat && hintVisible { hintBarView.pressKey(.left) }
        let edges = shift ? edgeDetector.decrementSkip(.right) : edgeDetector.incrementSkip(.left)
        if let edges { crosshairView.update(cursor: crosshairView.cursorPosition, edges: edges) }
    case 124: // Right arrow
        if !event.isARepeat && hintVisible { hintBarView.pressKey(.right) }
        let edges = shift ? edgeDetector.decrementSkip(.left) : edgeDetector.incrementSkip(.right)
        if let edges { crosshairView.update(cursor: crosshairView.cursorPosition, edges: edges) }
    case 125: // Down arrow
        if !event.isARepeat && hintVisible { hintBarView.pressKey(.down) }
        let edges = shift ? edgeDetector.decrementSkip(.top) : edgeDetector.incrementSkip(.bottom)
        if let edges { crosshairView.update(cursor: crosshairView.cursorPosition, edges: edges) }
    case 126: // Up arrow
        if !event.isARepeat && hintVisible { hintBarView.pressKey(.up) }
        let edges = shift ? edgeDetector.decrementSkip(.bottom) : edgeDetector.incrementSkip(.top)
        if let edges { crosshairView.update(cursor: crosshairView.cursorPosition, edges: edges) }
    default:
        break
    }
}
```

**Keep keyUp and flagsChanged** — subclass-specific (hint bar key animations for arrow keys and shift).

**Override deactivate():**
```swift
override func deactivate() {
    crosshairView.hideForDrag()
    if isHoveringSelection {
        isHoveringSelection = false
        CursorManager.shared.transitionBackToHidden()
        selectionManager.updateHover(at: .zero)
    }
    if isDragging {
        selectionManager.cancelDrag()
        isDragging = false
        CursorManager.shared.transitionBackToHidden()
    }
}
```

**Keep activate(firstMoveAlreadyReceived:)** — subclass-specific (different parameters for each window type).
Note: this needs to use inherited `hasReceivedFirstMove`. Currently it checks and sets the property directly. Since the base has `private(set)`, the subclass can read but not write. We need a way for the subclass to mark first move as received during activation. Add a `markFirstMoveReceived()` method to the base:
```swift
// In OverlayWindow base:
func markFirstMoveReceived() {
    hasReceivedFirstMove = true
}
```

Then in RulerWindow.activate():
```swift
func activate(firstMoveAlreadyReceived: Bool) {
    if firstMoveAlreadyReceived && !hasReceivedFirstMove {
        markFirstMoveReceived()
        crosshairView.skipSystemCrosshairPhase()
    }
    crosshairView.showAfterDrag()
    let mouse = NSEvent.mouseLocation
    let wp = NSPoint(x: mouse.x - screenBounds.origin.x, y: mouse.y - screenBounds.origin.y)
    let sp = NSPoint(x: screenBounds.origin.x + wp.x, y: screenBounds.origin.y + wp.y)
    if let edges = edgeDetector.onMouseMoved(at: sp) {
        crosshairView.update(cursor: wp, edges: edges)
    }
    if hintBarView.superview != nil {
        hintBarView.updatePosition(cursorY: wp.y, screenHeight: screenBounds.height)
    }
}
```

**Keep setBackground(_ cgImage:)** — RulerWindow's version adds the bgView below crosshairView specifically. Use the base's `setBackground(_:below:)` helper:
```swift
func setBackground(_ cgImage: CGImage) {
    setBackground(cgImage, below: crosshairView)
}
```

**Keep hasSelections computed property.**

**If `willHandleFirstMove()` or `markFirstMoveReceived()` are not present in OverlayWindow from Plan 01**, add them to OverlayWindow.swift:
- `func willHandleFirstMove() {}` — default no-op, called by base before `onFirstMove?()` in mouseMoved
- `func markFirstMoveReceived() { hasReceivedFirstMove = true }` — for subclass activation paths

And update the base's mouseMoved to call `willHandleFirstMove()` before `onFirstMove?()`.
  </action>
  <verify>
Run `cd /Users/haythem/Developer/design-ruler/swift/Ruler && swift build 2>&1 | head -30` — should compile with no errors. Verify RulerWindow no longer contains: `setupTrackingArea()`, `collapseHintBar()`, `mouseEntered(with:)`, `canBecomeKey`, `canBecomeMain`, `lastMoveTime`, or the 0.014 throttle guard.
  </verify>
  <done>RulerWindow is a thin OverlayWindow subclass containing only: edgeDetector, crosshairView, selectionManager, drag lifecycle (mouseDown/mouseDragged/mouseUp), arrow key handling, hover state management, and activate/deactivate. All shared window configuration, tracking, throttle, first-move, hint bar, and ESC handling come from the base.</done>
</task>

<task type="auto">
  <name>Task 2: Refactor AlignmentGuidesWindow to subclass OverlayWindow with CursorManager resize states</name>
  <files>swift/Ruler/Sources/AlignmentGuides/AlignmentGuidesWindow.swift</files>
  <action>
Change `AlignmentGuidesWindow` from `NSWindow, OverlayWindowProtocol` to `OverlayWindow`. Remove everything the base provides. Replace local resize cursor management with CursorManager calls.

**Class declaration:**
```swift
final class AlignmentGuidesWindow: OverlayWindow {
```

**Keep these subclass-specific properties:**
- `private var guideLineManager: GuideLineManager!`
- `private var cursorDirection: Direction = .vertical`

**Remove these (now in base):**
- `private(set) var targetScreen: NSScreen!` — inherited
- `private var hintBarView: HintBarView!` — inherited
- `private var screenBounds: CGRect = .zero` — inherited
- `private var lastMoveTime: Double = 0` — inherited
- `private var hasReceivedFirstMove = false` — inherited
- `private var lastCursorPosition: NSPoint = .zero` — inherited

**Callbacks — keep only typed + command-specific:**
- `var onActivate: ((AlignmentGuidesWindow) -> Void)?`
- `var onSpacebarPressed: (() -> Void)?`
- `var onSpacebarReleased: (() -> Void)?`
- `var onTabPressed: (() -> Void)?`
- `var onTabReleased: (() -> Void)?`
- Remove `onRequestExit`, `onFirstMove`, `onActivity` — inherited

**Remove the private PassthroughView class** — move it to be a private class INSIDE the file still (it's only used by AlignmentGuidesWindow's setupViews). Actually, keep it in the same file since it's only used here.

**Refactor create() factory:**
```swift
static func create(for screen: NSScreen, screenshot: CGImage?, hideHintBar: Bool) -> AlignmentGuidesWindow {
    let window = AlignmentGuidesWindow(
        contentRect: NSRect(origin: .zero, size: screen.frame.size),
        styleMask: .borderless,
        backing: .buffered,
        defer: false,
        screen: screen
    )
    OverlayWindow.configureOverlay(window, for: screen)
    window.setupViews(screenFrame: screen.frame, screenshot: screenshot, hideHintBar: hideHintBar)
    window.setupTrackingArea()
    return window
}
```

**Refactor setupViews** — use base's setupHintBar and setBackground:
```swift
private func setupViews(screenFrame: CGRect, screenshot: CGImage?, hideHintBar: Bool) {
    let size = screenFrame.size
    let containerView = NSView(frame: NSRect(origin: .zero, size: size))

    // Background image
    if let img = screenshot {
        let bgView = NSView(frame: NSRect(origin: .zero, size: size))
        bgView.wantsLayer = true
        bgView.layer?.contents = img
        bgView.layer?.contentsGravity = .resize
        containerView.addSubview(bgView)
    }

    // Guideline view (transparent, passes events through)
    let guidelineView = PassthroughView(frame: NSRect(origin: .zero, size: size))
    guidelineView.wantsLayer = true
    containerView.addSubview(guidelineView)

    let scale = backingScaleFactor
    self.guideLineManager = GuideLineManager(
        parentLayer: guidelineView.layer!,
        scale: scale,
        screenSize: size
    )

    contentView = containerView

    // Use base's shared hint bar setup with alignment guides mode
    setupHintBar(mode: .alignmentGuides, screenSize: size, screenshot: screenshot, hideHintBar: hideHintBar, container: containerView)
}
```

**Override handleActivation():**
```swift
override func handleActivation() {
    onActivate?(self)
}
```

**Remove collapseHintBar()** — inherited.
**Remove canBecomeKey/canBecomeMain** — inherited.
**Remove setupTrackingArea()** — inherited.
**Remove mouseEntered** — inherited via base.

**Override showInitialState():**
```swift
override func showInitialState() {
    let mouse = NSEvent.mouseLocation
    let pos = NSPoint(
        x: mouse.x - screenBounds.origin.x,
        y: mouse.y - screenBounds.origin.y
    )
    // Base tracks lastCursorPosition but it's private(set) — we need to update it.
    // Actually lastCursorPosition is internal(set) via the base. We can just read it.
    // But showInitialState runs before any mouseMoved, so we need to init position manually.
    // Use the base's method if available, or set directly.
    guideLineManager.showPreview()
    guideLineManager.updatePreview(at: pos)
    hintBarEntrance()
}
```

Wait — `lastCursorPosition` is `private(set)` in the base, so the subclass can read but not write. For showInitialState, the subclass needs to initialize `lastCursorPosition` (currently does this in the old code). Solutions:
- Make it `internal` (no access modifier) in the base so subclasses can set it directly
- Or add a setter method `updateCursorPosition(_:)` to the base

Since both subclasses need to set cursor position in their activate() methods, the cleanest solution is to provide an `initCursorPosition()` method in the base that reads NSEvent.mouseLocation and computes the window-local point:
```swift
// In OverlayWindow base:
func initCursorPosition() {
    let mouse = NSEvent.mouseLocation
    lastCursorPosition = NSPoint(
        x: mouse.x - screenBounds.origin.x,
        y: mouse.y - screenBounds.origin.y
    )
}
```

If this isn't in the base from Plan 01, add it. Then subclasses call `initCursorPosition()` in showInitialState/activate.

**Revised showInitialState:**
```swift
override func showInitialState() {
    initCursorPosition()
    guideLineManager.showPreview()
    guideLineManager.updatePreview(at: lastCursorPosition)
    hintBarEntrance()
}
```

**Override willHandleFirstMove():**
AlignmentGuides' first move needs to transition from systemCrosshair to the appropriate resize cursor:
```swift
override func willHandleFirstMove() {
    let resizeState: CursorManager.State = cursorDirection == .vertical ? .resizeLeftRight : .resizeUpDown
    if cursorDirection == .vertical {
        CursorManager.shared.transitionToResizeLeftRight()
    } else {
        CursorManager.shared.transitionToResizeUpDown()
    }
}
```

**Override handleMouseMoved(to:):**
```swift
override func handleMouseMoved(to windowPoint: NSPoint) {
    guideLineManager.updateHover(at: windowPoint)
    guideLineManager.updatePreview(at: windowPoint)

    // Cursor transitions for hover state — use CursorManager resize states
    if guideLineManager.hasHoveredLine {
        if CursorManager.shared.state != .pointingHand {
            CursorManager.shared.transitionToPointingHandFromResize()
        }
    } else {
        if CursorManager.shared.state == .pointingHand {
            CursorManager.shared.transitionToResize(cursorDirection)
        }
    }
}
```

Note: `lastCursorPosition` is updated by the base's mouseMoved BEFORE calling handleMouseMoved, so the subclass can read it via the inherited property.

**Remove resetCursorRects override** — no longer needed. Resize cursors are managed by CursorManager push/pop, not cursor rects. The system crosshair from the base's initial state will be replaced by the resize cursor on first move via `willHandleFirstMove()`.

Wait — actually, we need the initial cursor to be a resize cursor, not a crosshair. Currently AlignmentGuidesWindow uses `resetCursorRects` to show resize cursor on launch (before first mouse move). With the base class, the initial state is `systemCrosshair` in CursorManager.

Looking at current code: `showInitialState()` calls `setDirectionCursor()` which does `cursor.set()`. This sets the resize cursor immediately on launch, before any mouse movement.

With CursorManager: we need the launch state to show a resize cursor. Options:
1. Keep resetCursorRects in the subclass for the initial resize cursor display
2. Push the resize cursor in showInitialState via CursorManager

Option 2 is cleaner: in `showInitialState()`, call the appropriate CursorManager transition. But CursorManager starts in `systemCrosshair` state. We need a `transitionToResizeFromSystem` or similar.

Actually, `transitionToResizeUpDown()` and `transitionToResizeLeftRight()` already guard `state == .systemCrosshair`. So call the appropriate one in showInitialState:

```swift
override func showInitialState() {
    initCursorPosition()
    guideLineManager.showPreview()
    guideLineManager.updatePreview(at: lastCursorPosition)
    // Show resize cursor immediately (replacing system crosshair cursor rects)
    if cursorDirection == .vertical {
        CursorManager.shared.transitionToResizeLeftRight()
    } else {
        CursorManager.shared.transitionToResizeUpDown()
    }
    hintBarEntrance()
}
```

But wait — this pushes a resize cursor over the system cursor rects. The base class's `mouseEntered`/cursor rect system might still show crosshair underneath. Since OverlayWindow base doesn't override `resetCursorRects` (no default cursor rects), and the subclass is removing its `resetCursorRects` override, there won't be any cursor rects competing.

Actually, without any resetCursorRects override, NSWindow has no cursor rects at all, so the system arrow cursor is shown by default. The CursorManager push in showInitialState will override it. On first move, willHandleFirstMove would try to transition again but the guards will prevent double-transition (already in resize state, not systemCrosshair).

Hmm, but `willHandleFirstMove()` guards `state == .systemCrosshair`. After `showInitialState()` calls the resize transition, state is already `resizeLeftRight`/`resizeUpDown`. So `willHandleFirstMove()` becomes a no-op. That's fine — the resize cursor is already showing.

But there's a subtlety: if CursorManager.shared was already in a non-systemCrosshair state from a previous run, the transition in showInitialState won't fire. The coordinator's `run()` already resets CursorManager to systemCrosshair before window creation (via handleExit → restore, or resetCommandState). Let me verify... Looking at OverlayCoordinator.run(), it doesn't reset CursorManager explicitly. But it does call CursorManager.shared.restore() in handleExit(). For a fresh run, CursorManager should start in systemCrosshair (it's initialized that way).

OK this approach works. Remove `resetCursorRects`, `updateCursor()`, and `setDirectionCursor()` from AlignmentGuidesWindow.

**Refactor performToggleDirection()** — use CursorManager instead of local cursor management:
```swift
func performToggleDirection() {
    if hintBarView.superview != nil { hintBarView.pressKey(.tab) }
    guideLineManager.toggleDirection()
    cursorDirection = guideLineManager.direction
    // Switch resize cursor via CursorManager
    CursorManager.shared.switchResize(to: cursorDirection)
}
```

**Override sendEvent** for mouse routing:
```swift
override func sendEvent(_ event: NSEvent) {
    switch event.type {
    case .leftMouseDown: mouseDown(with: event)
    default: super.sendEvent(event)
    }
}
```

**Keep mouseDown** — subclass-specific, but update cursor transitions to use CursorManager:
```swift
override func mouseDown(with event: NSEvent) {
    onActivity?()
    let windowPoint = event.locationInWindow

    if guideLineManager.hasHoveredLine {
        guideLineManager.removeLine(guideLineManager.hoveredLine!, clickPoint: windowPoint)
        guideLineManager.resetRemoveMode()
        guideLineManager.updatePreview(at: windowPoint)
        // Revert to resize cursor via CursorManager
        CursorManager.shared.transitionToResize(cursorDirection)
        return
    }

    guideLineManager.placeGuide()
}
```

**Override handleKeyDown** for tab/spacebar:
```swift
override func handleKeyDown(with event: NSEvent) {
    switch Int(event.keyCode) {
    case 48: onTabPressed?()
    case 49: onSpacebarPressed?()
    default: break
    }
}
```

**Keep keyUp** — subclass-specific:
```swift
override func keyUp(with event: NSEvent) {
    switch Int(event.keyCode) {
    case 48: onTabReleased?()
    case 49: onSpacebarReleased?()
    default: break
    }
}
```

**Override deactivate():**
```swift
override func deactivate() {
    guideLineManager.hidePreview()
    if guideLineManager.hasHoveredLine {
        guideLineManager.updateHover(at: NSPoint(x: -100, y: -100))
        if CursorManager.shared.state == .pointingHand {
            CursorManager.shared.transitionToResize(cursorDirection)
        }
    }
}
```

Note: changed `transitionBackToSystem()` + `updateCursor()` to `transitionToResize(cursorDirection)` — CursorManager now manages the resize cursor state directly.

**Refactor activate():**
```swift
func activate(firstMoveAlreadyReceived: Bool, currentStyle: GuideLineStyle, currentDirection: Direction) {
    initCursorPosition()
    guideLineManager.setPreviewStyle(currentStyle)
    guideLineManager.setDirection(currentDirection)
    cursorDirection = currentDirection
    // Restore resize cursor via CursorManager
    CursorManager.shared.switchResize(to: cursorDirection)
    guideLineManager.showPreview()
    guideLineManager.updatePreview(at: lastCursorPosition)
    if hintBarView.superview != nil {
        hintBarView.updatePosition(cursorY: lastCursorPosition.y, screenHeight: screenBounds.height)
    }
}
```

**Ensure OverlayWindow.swift has these helper methods** (add if missing from Plan 01 execution):
- `willHandleFirstMove()` — default no-op, called by base before `onFirstMove?()` in mouseMoved
- `markFirstMoveReceived()` — sets `hasReceivedFirstMove = true`
- `initCursorPosition()` — reads NSEvent.mouseLocation and sets `lastCursorPosition` to window-local coords
- `hintBarEntrance()` — calls `hintBarView.animateEntrance()` if hint bar has a superview

If any are missing, add them to OverlayWindow.swift.
  </action>
  <verify>
Run `cd /Users/haythem/Developer/design-ruler/swift/Ruler && swift build 2>&1 | head -30` — should compile with no errors. Verify:
1. AlignmentGuidesWindow no longer contains: `resetCursorRects`, `updateCursor()`, `setDirectionCursor()`, `setupTrackingArea()`, `collapseHintBar()`, `mouseEntered(with:)`, `canBecomeKey`, `canBecomeMain`, `lastMoveTime`, the 0.014 throttle guard
2. RulerWindow no longer contains: `setupTrackingArea()`, `collapseHintBar()`, `mouseEntered(with:)`, `canBecomeKey`, `canBecomeMain`, `lastMoveTime`, the 0.014 throttle guard
3. Both subclass OverlayWindow (not NSWindow directly)
4. No `NSCursor.set()`, `.resizeUpDown`, or `.resizeLeftRight` appear in AlignmentGuidesWindow — all resize cursor logic goes through CursorManager
  </verify>
  <done>AlignmentGuidesWindow is a thin OverlayWindow subclass using CursorManager for all cursor states (including resize), and RulerWindow is a thin OverlayWindow subclass. No duplicated window configuration, tracking, throttle, first-move, hint bar, or ESC handling remains in either subclass.</done>
</task>

</tasks>

<verification>
1. `swift build` succeeds with zero errors
2. RulerWindow subclasses OverlayWindow, not NSWindow
3. AlignmentGuidesWindow subclasses OverlayWindow, not NSWindow
4. Neither window contains: setupTrackingArea, collapseHintBar, mouseEntered, canBecomeKey/canBecomeMain, lastMoveTime, or the 0.014 throttle
5. AlignmentGuidesWindow has no resetCursorRects, updateCursor, setDirectionCursor — all resize cursor logic is via CursorManager
6. No `NSCursor.resizeUpDown` or `NSCursor.resizeLeftRight` appears in AlignmentGuidesWindow.swift
7. `grep -c "class RulerWindow: OverlayWindow" swift/Ruler/Sources/RulerWindow.swift` returns 1
8. `grep -c "class AlignmentGuidesWindow: OverlayWindow" swift/Ruler/Sources/AlignmentGuides/AlignmentGuidesWindow.swift` returns 1
</verification>

<success_criteria>
- Both windows are thin OverlayWindow subclasses with only command-specific logic
- CursorManager resize states fully replace AlignmentGuidesWindow's local cursor management
- Project builds cleanly
- Phase 15 success criteria all met: WIND-01 through WIND-04 and CURS-01
</success_criteria>

<output>
After completion, create `.planning/phases/15-window-base-cursor/15-02-SUMMARY.md`
</output>
