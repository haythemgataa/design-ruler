---
phase: 15-window-base-cursor
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - swift/Ruler/Sources/Utilities/OverlayWindow.swift
  - swift/Ruler/Sources/Cursor/CursorManager.swift
autonomous: true

must_haves:
  truths:
    - "Shared NSWindow configuration (10 properties) exists once in OverlayWindow base class"
    - "setupTrackingArea, collapseHintBar, mouseEntered, canBecomeKey/canBecomeMain exist once in the base"
    - "Mouse move throttle (0.014s) and first-move detection exist once in the base"
    - "CursorManager has resizeUpDown and resizeLeftRight states with proper push/pop transitions"
  artifacts:
    - path: "swift/Ruler/Sources/Utilities/OverlayWindow.swift"
      provides: "Overlay window base class with shared configuration, tracking, throttling, hint bar, events"
      contains: "class OverlayWindow"
    - path: "swift/Ruler/Sources/Cursor/CursorManager.swift"
      provides: "Extended cursor state machine with resize cursor states"
      contains: "resizeUpDown"
  key_links:
    - from: "swift/Ruler/Sources/Utilities/OverlayWindow.swift"
      to: "swift/Ruler/Sources/Cursor/CursorManager.swift"
      via: "first-move transition calls CursorManager"
      pattern: "CursorManager\\.shared"
    - from: "swift/Ruler/Sources/Utilities/OverlayWindow.swift"
      to: "swift/Ruler/Sources/Rendering/HintBarView.swift"
      via: "base owns hint bar creation, collapse, positioning"
      pattern: "hintBarView"
---

<objective>
Create the OverlayWindow base class and extend CursorManager with resize cursor states.

Purpose: Provides the shared foundation that both RulerWindow and AlignmentGuidesWindow will subclass in Plan 02, eliminating all duplicated window configuration, event handling, and tracking code.

Output: OverlayWindow.swift base class + updated CursorManager.swift with resize states.
</objective>

<execution_context>
@/Users/haythem/.claude/get-shit-done/workflows/execute-plan.md
@/Users/haythem/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@swift/Ruler/Sources/RulerWindow.swift
@swift/Ruler/Sources/AlignmentGuides/AlignmentGuidesWindow.swift
@swift/Ruler/Sources/Cursor/CursorManager.swift
@swift/Ruler/Sources/Utilities/OverlayCoordinator.swift
@swift/Ruler/Sources/Rendering/HintBarView.swift
@swift/Ruler/Sources/Rendering/HintBarContent.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create OverlayWindow base class</name>
  <files>swift/Ruler/Sources/Utilities/OverlayWindow.swift</files>
  <action>
Create `OverlayWindow.swift` in the Utilities directory. This is a class (not final) that subclasses NSWindow and conforms to OverlayWindowProtocol.

**Class declaration:**
```swift
class OverlayWindow: NSWindow, OverlayWindowProtocol {
```

**Stored properties (from both windows):**
- `private(set) var targetScreen: NSScreen!` (from OverlayWindowProtocol)
- `var hintBarView: HintBarView!` (internal access so subclasses can check `hintBarView.superview != nil` for key press animations)
- `var screenBounds: CGRect = .zero` (internal access for subclass coordinate conversions)
- `private var lastMoveTime: Double = 0`
- `private(set) var hasReceivedFirstMove = false` (subclasses read this but base manages it)
- `private(set) var lastCursorPosition: NSPoint = .zero` (subclasses read this; base updates it in mouseMoved)

**Callbacks (shared across both windows):**
- `var onRequestExit: (() -> Void)?`
- `var onFirstMove: (() -> Void)?`
- `var onActivity: (() -> Void)?`

Note: `onActivate` is NOT in the base because it's typed to the concrete window class (RulerWindow vs AlignmentGuidesWindow). Each subclass declares its own typed `onActivate`.

**Static factory helper** for shared NSWindow configuration — called by subclass `create()` methods:
```swift
static func configureOverlay(_ window: OverlayWindow, for screen: NSScreen) {
    window.setFrame(screen.frame, display: false)
    window.targetScreen = screen
    window.screenBounds = screen.frame
    window.level = .statusBar
    window.isOpaque = true
    window.hasShadow = false
    window.backgroundColor = .black
    window.acceptsMouseMovedEvents = true
    window.ignoresMouseEvents = false
    window.collectionBehavior = [.canJoinAllSpaces, .fullScreenAuxiliary]
}
```

This is a static method (not an instance method on init) because both subclass `create()` factories already call `NSWindow.init(contentRect:styleMask:backing:defer:screen:)` — the base can't override that init due to NSWindow's init patterns. Subclasses call `configureOverlay(window, for: screen)` immediately after creating the window.

**setupTrackingArea()** — identical to both current implementations:
```swift
func setupTrackingArea() {
    guard let cv = contentView else { return }
    let area = NSTrackingArea(
        rect: cv.bounds,
        options: [.mouseEnteredAndExited, .activeAlways],
        owner: self, userInfo: nil
    )
    cv.addTrackingArea(area)
}
```

**collapseHintBar()** — identical in both:
```swift
func collapseHintBar() {
    guard hintBarView.superview != nil else { return }
    hintBarView.animateToCollapsed()
}
```

**setupHintBar(mode:screenSize:screenshot:hideHintBar:container:)** — shared hint bar instantiation helper parameterized by mode (WIND-04):
```swift
func setupHintBar(mode: HintBarMode, screenSize: CGSize, screenshot: CGImage?, hideHintBar: Bool, container: NSView) {
    let hv = HintBarView(frame: .zero)
    self.hintBarView = hv
    if !hideHintBar {
        if mode != .inspect { hv.setMode(mode) }
        hv.configure(screenWidth: screenSize.width, screenHeight: screenSize.height, screenshot: screenshot)
        container.addSubview(hv)
    }
}
```

Note the critical setup order from CLAUDE.md: `setMode()` MUST be called BEFORE `configure()`. The default mode is `.inspect`, so we only call `setMode()` when mode is NOT inspect (avoids unnecessary call for design ruler).

**canBecomeKey / canBecomeMain:**
```swift
override var canBecomeKey: Bool { true }
override var canBecomeMain: Bool { true }
```

**mouseEntered** — base owns completely per locked decision. Calls a `handleActivation()` method that subclasses override:
```swift
override func mouseEntered(with event: NSEvent) {
    handleActivation()
}
```

`handleActivation()` is an overridable method. Each subclass calls its typed `onActivate` callback from here:
```swift
func handleActivation() {
    // Subclasses override to call their typed onActivate callback
}
```

**mouseMoved** — base owns throttle, first-move detection, cursor position tracking, hint bar positioning. Calls subclass `handleMouseMoved(to:)`:
```swift
override func mouseMoved(with event: NSEvent) {
    let now = CACurrentMediaTime()
    guard now - lastMoveTime >= 0.014 else { return }
    lastMoveTime = now
    onActivity?()

    if !hasReceivedFirstMove {
        hasReceivedFirstMove = true
        onFirstMove?()
    }

    let windowPoint = event.locationInWindow
    lastCursorPosition = windowPoint

    handleMouseMoved(to: windowPoint)

    if hintBarView.superview != nil {
        hintBarView.updatePosition(cursorY: windowPoint.y, screenHeight: screenBounds.height)
    }
}
```

Note: hint bar positioning runs AFTER `handleMouseMoved(to:)` so the subclass processes the point first.

**handleMouseMoved(to:)** — overridable hook:
```swift
func handleMouseMoved(to windowPoint: NSPoint) {
    // Subclasses override for command-specific mouse move handling
}
```

**keyDown** — base handles ESC, forwards all other keys to subclass:
```swift
override func keyDown(with event: NSEvent) {
    onActivity?()
    if Int(event.keyCode) == 53 { // ESC
        if hintBarView.superview != nil { hintBarView.pressKey(.esc) }
        onRequestExit?()
        return
    }
    handleKeyDown(with: event)
}
```

**handleKeyDown(with:)** — overridable hook:
```swift
func handleKeyDown(with event: NSEvent) {
    // Subclasses override for command-specific key handling
}
```

**showInitialState()** from OverlayWindowProtocol — remains abstract (subclasses must override):
```swift
func showInitialState() {
    // Subclasses override for command-specific initial state
}
```

**deactivate()** from OverlayWindowProtocol — remains abstract:
```swift
func deactivate() {
    // Subclasses override for command-specific deactivation
}
```

**setBackground(_ cgImage:)** — shared helper for frozen screenshot background (used by both windows in different ways but same implementation):
```swift
func setBackground(_ cgImage: CGImage, below referenceView: NSView) {
    guard let container = contentView else { return }
    let bgView = NSView(frame: NSRect(origin: .zero, size: screenBounds.size))
    bgView.wantsLayer = true
    bgView.layer?.contents = cgImage
    bgView.layer?.contentsGravity = .resize
    container.addSubview(bgView, positioned: .below, relativeTo: referenceView)
}
```

**hintBarEntrance()** — shared pattern for showing hint bar entrance animation:
```swift
func hintBarEntrance() {
    if hintBarView.superview != nil { hintBarView.animateEntrance() }
}
```

Do NOT include `sendEvent`, `mouseDown`, `mouseUp`, `mouseDragged`, `keyUp`, `flagsChanged` in the base — per locked decisions, subclasses own clicks entirely and all non-ESC key events.
  </action>
  <verify>
Run `cd /Users/haythem/Developer/design-ruler/swift/Ruler && swift build 2>&1 | head -20` — should compile with no errors. The new file adds no dependencies on existing code yet.
  </verify>
  <done>OverlayWindow.swift exists with all shared window configuration, tracking area, hint bar management, throttled mouse move with first-move detection, ESC handling, mouseEntered delegation, and overridable hooks (handleMouseMoved, handleKeyDown, handleActivation, showInitialState, deactivate).</done>
</task>

<task type="auto">
  <name>Task 2: Extend CursorManager with resize cursor states</name>
  <files>swift/Ruler/Sources/Cursor/CursorManager.swift</files>
  <action>
Add `resizeUpDown` and `resizeLeftRight` to CursorManager's State enum and add corresponding transitions.

**State enum additions:**
```swift
case resizeUpDown      // Alignment guides: horizontal preview line, resize cursor visible
case resizeLeftRight   // Alignment guides: vertical preview line, resize cursor visible
```

**New transitions:**

1. `transitionToResizeUpDown()` — from systemCrosshair (first move in alignment guides with horizontal direction):
```swift
func transitionToResizeUpDown() {
    guard state == .systemCrosshair else { return }
    NSCursor.resizeUpDown.push()
    pushCount += 1
    state = .resizeUpDown
}
```

2. `transitionToResizeLeftRight()` — from systemCrosshair (first move in alignment guides with vertical direction):
```swift
func transitionToResizeLeftRight() {
    guard state == .systemCrosshair else { return }
    NSCursor.resizeLeftRight.push()
    pushCount += 1
    state = .resizeLeftRight
}
```

3. `transitionToPointingHandFromResize()` — when hovering a placed line while in resize state:
```swift
func transitionToPointingHandFromResize() {
    guard state == .resizeUpDown || state == .resizeLeftRight else { return }
    NSCursor.pop()
    pushCount = max(pushCount - 1, 0)
    NSCursor.pointingHand.push()
    pushCount += 1
    state = .pointingHand
}
```

4. `transitionToResize(_ direction: Direction)` — return to resize from pointingHand (unhover):
```swift
func transitionToResize(_ direction: Direction) {
    guard state == .pointingHand else { return }
    NSCursor.pop()
    pushCount = max(pushCount - 1, 0)
    let cursor: NSCursor = direction == .vertical ? .resizeLeftRight : .resizeUpDown
    cursor.push()
    pushCount += 1
    state = direction == .vertical ? .resizeLeftRight : .resizeUpDown
}
```

5. `switchResize(to direction: Direction)` — switch between resize directions (tab toggle):
```swift
func switchResize(to direction: Direction) {
    guard state == .resizeUpDown || state == .resizeLeftRight else { return }
    let newState: State = direction == .vertical ? .resizeLeftRight : .resizeUpDown
    guard state != newState else { return }
    NSCursor.pop()
    pushCount = max(pushCount - 1, 0)
    let cursor: NSCursor = direction == .vertical ? .resizeLeftRight : .resizeUpDown
    cursor.push()
    pushCount += 1
    state = newState
}
```

**Update `transitionBackToHidden()`** to also handle resize states (for robustness):
In the switch statement, add `case .resizeUpDown, .resizeLeftRight:` alongside `.pointingHand, .crosshairDrag:` — same logic (pop + hide).

**Update `transitionBackToSystem()`** to also handle resize states:
Add `case .resizeUpDown, .resizeLeftRight:` alongside `.pointingHand:` — same logic (pop).

Wait — actually `transitionBackToSystem` currently only guards `state == .pointingHand`. Change it to:
```swift
func transitionBackToSystem() {
    switch state {
    case .pointingHand, .resizeUpDown, .resizeLeftRight:
        NSCursor.pop()
        pushCount = max(pushCount - 1, 0)
        state = .systemCrosshair
    default:
        break
    }
}
```

**Update the `restore()` method** — no changes needed, it already pops all pushed cursors unconditionally by count.

**Import Direction type:** Direction enum is already available (defined in GuideLineManager or similar). Verify it's accessible — if it's defined in AlignmentGuides scope, it should be visible since all Swift files are in the same module.

Note: The `Direction` enum is used by `switchResize(to:)` and `transitionToResize(_:)`. This is acceptable since CursorManager is shared and already in the same Swift module as the AlignmentGuides code.
  </action>
  <verify>
Run `cd /Users/haythem/Developer/design-ruler/swift/Ruler && swift build 2>&1 | head -20` — should compile with no errors. The new states and transitions don't break any existing callers since old call sites still use their existing transition methods.
  </verify>
  <done>CursorManager has 6 states (systemCrosshair, hidden, pointingHand, crosshairDrag, resizeUpDown, resizeLeftRight) with all necessary transitions for alignment guides resize cursor management, and existing transitions still work for design ruler.</done>
</task>

</tasks>

<verification>
1. `swift build` succeeds with zero errors
2. OverlayWindow.swift contains: configureOverlay, setupTrackingArea, collapseHintBar, setupHintBar, mouseEntered, mouseMoved with throttle + firstMove, keyDown with ESC, handleMouseMoved/handleKeyDown/handleActivation hooks
3. CursorManager.swift contains: resizeUpDown, resizeLeftRight states, transitionToResizeUpDown, transitionToResizeLeftRight, transitionToPointingHandFromResize, transitionToResize, switchResize
4. No existing code is broken (RulerWindow and AlignmentGuidesWindow unchanged)
</verification>

<success_criteria>
- OverlayWindow base class compiles and contains all shared window logic identified in WIND-01 through WIND-04
- CursorManager has resize states per CURS-01
- Project builds cleanly
- No changes to existing window files (they'll be refactored in Plan 02)
</success_criteria>

<output>
After completion, create `.planning/phases/15-window-base-cursor/15-01-SUMMARY.md`
</output>
