---
phase: 14-coordinator-base
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - swift/Ruler/Sources/Utilities/OverlayCoordinator.swift
  - swift/Ruler/Sources/Utilities/ScreenCapture.swift
  - swift/Ruler/Sources/Utilities/CoordinateConverter.swift
autonomous: true

must_haves:
  truths:
    - "OverlayCoordinator base class encapsulates the full startup sequence (warmup -> permissions -> cursor screen -> capture -> create windows -> .accessory -> show -> run loop)"
    - "ScreenCapture.captureScreen() is a standalone utility returning CGImage, usable by both EdgeDetector and AlignmentGuides"
    - "CoordinateConverter has appKitRectToCG and cgRectToAppKit replacing inline rect conversions"
  artifacts:
    - path: "swift/Ruler/Sources/Utilities/OverlayCoordinator.swift"
      provides: "Base class with shared lifecycle, window factory protocol, signal handler, inactivity timer, first-move handling, exit"
      contains: "class OverlayCoordinator"
    - path: "swift/Ruler/Sources/Utilities/ScreenCapture.swift"
      provides: "Shared screen capture utility returning CGImage"
      contains: "enum ScreenCapture"
    - path: "swift/Ruler/Sources/Utilities/CoordinateConverter.swift"
      provides: "Rect conversion methods alongside existing point conversions"
      contains: "appKitRectToCG"
  key_links:
    - from: "OverlayCoordinator.swift"
      to: "ScreenCapture.swift"
      via: "calls ScreenCapture.captureScreen in capture loop"
      pattern: "ScreenCapture\\.captureScreen"
    - from: "OverlayCoordinator.swift"
      to: "PermissionChecker.swift"
      via: "calls permission check in startup sequence"
      pattern: "PermissionChecker"
    - from: "ScreenCapture.swift"
      to: "CoordinateConverter.swift"
      via: "uses appKitRectToCG for capture rect conversion"
      pattern: "CoordinateConverter\\.appKitRectToCG"
---

<objective>
Create the OverlayCoordinator base class, shared ScreenCapture utility, and CoordinateConverter rect methods that will be consumed by both Ruler.swift and AlignmentGuides.swift.

Purpose: Establish the shared foundation so both commands can delegate lifecycle orchestration to a common base instead of reimplementing it.
Output: Three files — OverlayCoordinator.swift (base class), ScreenCapture.swift (capture utility), CoordinateConverter.swift (extended with rect methods).
</objective>

<execution_context>
@/Users/haythem/.claude/get-shit-done/workflows/execute-plan.md
@/Users/haythem/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/14-coordinator-base/14-CONTEXT.md

@swift/Ruler/Sources/Ruler.swift
@swift/Ruler/Sources/AlignmentGuides/AlignmentGuides.swift
@swift/Ruler/Sources/Utilities/CoordinateConverter.swift
@swift/Ruler/Sources/Permissions/PermissionChecker.swift
@swift/Ruler/Sources/EdgeDetection/EdgeDetector.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ScreenCapture utility and extend CoordinateConverter</name>
  <files>
    swift/Ruler/Sources/Utilities/ScreenCapture.swift
    swift/Ruler/Sources/Utilities/CoordinateConverter.swift
  </files>
  <action>
**ScreenCapture.swift** — Create a new `enum ScreenCapture` (stateless utility, matching the PermissionChecker pattern):

```swift
enum ScreenCapture {
    static func captureScreen(_ screen: NSScreen) -> CGImage? {
        let cgRect = CoordinateConverter.appKitRectToCG(screen.frame)
        return CGWindowListCreateImage(
            cgRect,
            .optionOnScreenOnly,
            kCGNullWindowID,
            .bestResolution
        )
    }
}
```

This is the shared capture extracted from `AlignmentGuides.captureScreen()` and `EdgeDetector.capture()`. Returns CGImage only — per locked decision, EdgeDetector wraps into ColorMap separately.

**CoordinateConverter.swift** — Add two rect conversion methods (CORD-05) to the existing enum:

```swift
/// Convert AppKit rect (bottom-left origin) to CG rect (top-left origin)
static func appKitRectToCG(_ rect: NSRect) -> CGRect {
    guard let mainHeight = NSScreen.screens.first?.frame.height else {
        return CGRect(x: rect.origin.x, y: rect.origin.y, width: rect.width, height: rect.height)
    }
    return CGRect(
        x: rect.origin.x,
        y: mainHeight - rect.origin.y - rect.height,
        width: rect.width,
        height: rect.height
    )
}

/// Convert CG rect (top-left origin) to AppKit rect (bottom-left origin)
static func cgRectToAppKit(_ rect: CGRect) -> NSRect {
    guard let mainHeight = NSScreen.screens.first?.frame.height else {
        return NSRect(x: rect.origin.x, y: rect.origin.y, width: rect.width, height: rect.height)
    }
    return NSRect(
        x: rect.origin.x,
        y: mainHeight - rect.origin.y - rect.height,
        width: rect.width,
        height: rect.height
    )
}
```

These replace the 2 inline `mainHeight - frame.origin.y - frame.height` patterns in EdgeDetector.swift and AlignmentGuides.swift (which will be wired in Plan 02).
  </action>
  <verify>Project builds: `cd /Users/haythem/Developer/design-ruler/swift/Ruler && swift build 2>&1 | tail -5` — should succeed with no errors. Existing tests still pass if any.</verify>
  <done>ScreenCapture.captureScreen() exists and compiles. CoordinateConverter.appKitRectToCG() and cgRectToAppKit() exist alongside the existing point methods.</done>
</task>

<task type="auto">
  <name>Task 2: Create OverlayCoordinator base class</name>
  <files>
    swift/Ruler/Sources/Utilities/OverlayCoordinator.swift
  </files>
  <action>
Create `OverlayCoordinator.swift` with a base class that encapsulates all shared lifecycle operations. Use a class (not protocol) since both coordinators need shared stored state (windows array, timers, flags). Subclasses override a window factory method.

The base class must:

1. **Properties** (all the duplicated state):
   - `windows: [NSWindow]` (typed as NSWindow; subclasses downcast)
   - `activeWindow: NSWindow?` (weak)
   - `cursorWindow: NSWindow?` (weak)
   - `firstMoveReceived: Bool`
   - `launchTime: CFAbsoluteTime`
   - `minExpandedDuration: TimeInterval = 3`
   - `inactivityTimer: Timer?`
   - `inactivityTimeout: TimeInterval = 600`
   - `sigTermSource: DispatchSourceSignal?`

2. **run(hideHintBar:)** — The orchestrated startup sequence enforcing the LOCKED order:
   ```
   warmup capture (1x1) -> permission check -> detect cursor screen ->
   captureScreens() -> createWindows() -> .accessory policy -> cleanup old windows ->
   show all windows -> make key window -> launchTime -> activate -> signal handler -> inactivity timer -> app.run()
   ```
   The `captureScreens()` and `createWindows()` steps call overridable methods on the subclass.

3. **Overridable methods** (subclasses provide command-specific behavior):
   - `func captureAllScreens() -> [(screen: NSScreen, image: CGImage?)]` — Default implementation uses `ScreenCapture.captureScreen()` for each screen. Ruler overrides to capture via EdgeDetector instead.
   - `func createWindow(for screen: NSScreen, image: CGImage?, isCursorScreen: Bool, hideHintBar: Bool) -> NSWindow` — Abstract-like (fatalError default). Each subclass creates its specific window type.
   - `func wireCallbacks(for window: NSWindow)` — Default wires the 4 common callbacks (onActivate, onRequestExit, onFirstMove, onActivity). AlignmentGuides overrides to add spacebar/tab callbacks.
   - `func activateWindow(_ window: NSWindow)` — Default implementation handles resetInactivityTimer, guard, deactivate old, makeKey, activate new. AlignmentGuides overrides to pass currentStyle/currentDirection.
   - `func showInitialState(for window: NSWindow)` — Calls through to window's showInitialState. Default just calls `(window as? RulerWindow)?.showInitialState()` etc — or better, define a protocol.

4. **Shared methods** (exist once, not overridden):
   - `handleExit()` — CursorManager.shared.restore(), close all windows, NSApp.terminate(nil)
   - `handleFirstMove()` — set flag, delayed/immediate collapseHintBar based on elapsed time
   - `setupSignalHandler()` — SIGTERM DispatchSource calling handleExit
   - `resetInactivityTimer()` — invalidate + schedule 600s timer calling handleExit

5. **Window protocol** — Define a lightweight protocol that both RulerWindow and AlignmentGuidesWindow already satisfy, to allow the base to call common methods without downcasting:
   ```swift
   protocol OverlayWindow: AnyObject {
       var targetScreen: NSScreen! { get }
       var onActivate: ((Self) -> Void)? { get set }  // Note: this won't work with protocol
       var onRequestExit: (() -> Void)? { get set }
       var onFirstMove: (() -> Void)? { get set }
       var onActivity: (() -> Void)? { get set }
       func showInitialState()
       func collapseHintBar()
       func deactivate()
   }
   ```
   Actually, since `onActivate` is generic per window type, it's cleaner to use a type-erased approach or just keep the callback wiring in the subclass overrides. Use your judgment — the goal is that `handleFirstMove()` and `handleExit()` can operate on `windows` without knowing the concrete type.

   A pragmatic approach: the base stores `windows` as `[NSWindow]`. Define a minimal `OverlayWindowProtocol` with just the methods the base needs to call: `showInitialState()`, `collapseHintBar()`, `deactivate()`, `var targetScreen: NSScreen! { get }`, `func makeKey()` (already on NSWindow). Both window classes conform. The base casts to protocol where needed.

**Critical constraints:**
- The base MUST NOT import or reference RulerWindow or AlignmentGuidesWindow directly (it lives in Utilities/)
- The `run()` method enforces the capture order — subclasses cannot reorder the sequence (per locked decision)
- `handleFirstMove` references `cursorWindow` which needs collapseHintBar — use the protocol cast
- Keep `init()` as `init()` (not private) so subclasses can inherit
  </action>
  <verify>Project builds: `cd /Users/haythem/Developer/design-ruler/swift/Ruler && swift build 2>&1 | tail -5` — should succeed. The base class compiles standalone without being consumed yet.</verify>
  <done>OverlayCoordinator base class exists with run(), handleExit(), handleFirstMove(), setupSignalHandler(), resetInactivityTimer(), overridable captureAllScreens/createWindow/wireCallbacks/activateWindow methods, and an OverlayWindow protocol for type-safe access to shared window methods.</done>
</task>

</tasks>

<verification>
1. `swift build` succeeds in `/Users/haythem/Developer/design-ruler/swift/Ruler/`
2. OverlayCoordinator.swift contains: run(), handleExit(), handleFirstMove(), setupSignalHandler(), resetInactivityTimer()
3. ScreenCapture.swift contains captureScreen() using CoordinateConverter.appKitRectToCG()
4. CoordinateConverter.swift contains appKitRectToCG() and cgRectToAppKit() alongside existing point methods
5. No compilation errors (the base class and utilities are self-contained, not yet consumed)
</verification>

<success_criteria>
- OverlayCoordinator base class compiles with the full lifecycle sequence
- ScreenCapture.captureScreen() compiles as a standalone utility
- CoordinateConverter has both point and rect conversion methods
- Project builds successfully (no existing code broken)
</success_criteria>

<output>
After completion, create `.planning/phases/14-coordinator-base/14-01-SUMMARY.md`
</output>
