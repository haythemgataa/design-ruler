---
phase: 14-coordinator-base
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - swift/Ruler/Sources/Ruler.swift
  - swift/Ruler/Sources/AlignmentGuides/AlignmentGuides.swift
  - swift/Ruler/Sources/EdgeDetection/EdgeDetector.swift
  - swift/Ruler/Sources/RulerWindow.swift
  - swift/Ruler/Sources/AlignmentGuides/AlignmentGuidesWindow.swift
autonomous: true

must_haves:
  truths:
    - "Ruler.swift subclasses OverlayCoordinator and only contains command-specific logic (EdgeDetector capture, correction mode, window factory)"
    - "AlignmentGuides.swift subclasses OverlayCoordinator and only contains command-specific logic (style/direction state, spacebar/tab callbacks, window factory)"
    - "handleExit, handleFirstMove, setupSignalHandler, resetInactivityTimer are NOT reimplemented in either command file"
    - "EdgeDetector.capture() uses ScreenCapture.captureScreen() instead of inline CGWindowListCreateImage"
    - "Both commands launch, run, and exit with identical behavior to before"
  artifacts:
    - path: "swift/Ruler/Sources/Ruler.swift"
      provides: "Ruler coordinator subclass with @raycast entry point"
      contains: "class Ruler: OverlayCoordinator"
    - path: "swift/Ruler/Sources/AlignmentGuides/AlignmentGuides.swift"
      provides: "AlignmentGuides coordinator subclass with @raycast entry point"
      contains: "class AlignmentGuides: OverlayCoordinator"
    - path: "swift/Ruler/Sources/EdgeDetection/EdgeDetector.swift"
      provides: "EdgeDetector using shared ScreenCapture utility"
      contains: "ScreenCapture.captureScreen"
  key_links:
    - from: "Ruler.swift"
      to: "OverlayCoordinator.swift"
      via: "subclass calling super.run()"
      pattern: "class Ruler: OverlayCoordinator"
    - from: "AlignmentGuides.swift"
      to: "OverlayCoordinator.swift"
      via: "subclass calling super.run()"
      pattern: "class AlignmentGuides: OverlayCoordinator"
    - from: "EdgeDetector.swift"
      to: "ScreenCapture.swift"
      via: "calls ScreenCapture.captureScreen for capture"
      pattern: "ScreenCapture\\.captureScreen"
    - from: "RulerWindow.swift"
      to: "OverlayCoordinator.swift"
      via: "conforms to OverlayWindow protocol"
      pattern: "OverlayWindow"
    - from: "AlignmentGuidesWindow.swift"
      to: "OverlayCoordinator.swift"
      via: "conforms to OverlayWindow protocol"
      pattern: "OverlayWindow"
---

<objective>
Refactor Ruler.swift and AlignmentGuides.swift to subclass OverlayCoordinator, wire EdgeDetector to use ScreenCapture, and conform both window types to OverlayWindow protocol.

Purpose: Eliminate all duplicated lifecycle code — both commands become thin "configuration + factory" subclasses of the shared base.
Output: Five modified files with zero duplicated lifecycle code between the two commands.
</objective>

<execution_context>
@/Users/haythem/.claude/get-shit-done/workflows/execute-plan.md
@/Users/haythem/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/14-coordinator-base/14-CONTEXT.md
@.planning/phases/14-coordinator-base/14-01-SUMMARY.md

@swift/Ruler/Sources/Ruler.swift
@swift/Ruler/Sources/AlignmentGuides/AlignmentGuides.swift
@swift/Ruler/Sources/EdgeDetection/EdgeDetector.swift
@swift/Ruler/Sources/RulerWindow.swift
@swift/Ruler/Sources/AlignmentGuides/AlignmentGuidesWindow.swift
@swift/Ruler/Sources/Utilities/OverlayCoordinator.swift
@swift/Ruler/Sources/Utilities/ScreenCapture.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor Ruler.swift and EdgeDetector.swift to use shared base and capture</name>
  <files>
    swift/Ruler/Sources/Ruler.swift
    swift/Ruler/Sources/EdgeDetection/EdgeDetector.swift
    swift/Ruler/Sources/RulerWindow.swift
  </files>
  <action>
**Ruler.swift** — Rewrite to subclass OverlayCoordinator. The `@raycast func inspect()` stays in this file. After refactoring, Ruler should contain ONLY:

1. `@raycast func inspect(hideHintBar:corrections:)` — calls `Ruler.shared.run(hideHintBar:corrections:)` (NO warmup capture here — it moved into the base)
2. `class Ruler: OverlayCoordinator` with `static let shared = Ruler()`
3. Command-specific stored properties: `correctionMode: CorrectionMode` and `detectors: [NSScreen: EdgeDetector]` (or similar structure to pass detectors to window factory)
4. `run(hideHintBar:corrections:)` — stores correctionMode, then calls `super.run(hideHintBar: hideHintBar)` (the base handles everything else)
5. Override `captureAllScreens()` — captures via EdgeDetector per screen (creates detector, sets correctionMode, calls `detector.capture(screen:)`, stores detector for later use in window creation). Returns `[(screen, image)]` tuples.
6. Override `createWindow(for:image:isCursorScreen:hideHintBar:)` — creates `RulerWindow.create(for:edgeDetector:hideHintBar:screenshot:)`, sets background from cgImage, returns window. Retrieves the detector stored during capture phase.
7. Override `wireCallbacks(for:)` — calls `super.wireCallbacks(for:)` for the 4 standard callbacks (which the base wires via the OverlayWindow protocol or downcast). Ruler has no extra callbacks beyond the 4 standard ones.
8. Override `activateWindow(_:)` — calls base activation (or super) which handles the common pattern. If the base's default implementation suffices (resetInactivityTimer, guard, deactivate old, makeKey, activate new with firstMoveAlreadyReceived), then Ruler may not even need to override this.

**Delete from Ruler.swift**: handleExit(), handleFirstMove(), setupSignalHandler(), resetInactivityTimer(), all the duplicated stored properties (inactivityTimer, sigTermSource, launchTime, minExpandedDuration, inactivityTimeout, firstMoveReceived, activeWindow, cursorWindow, windows).

**EdgeDetector.swift** — Refactor `capture(screen:)` to use `ScreenCapture.captureScreen()` instead of inline CGWindowListCreateImage:

```swift
func capture(screen: NSScreen) -> CGImage? {
    guard let cgImage = ScreenCapture.captureScreen(screen) else { return nil }
    let cgRect = CoordinateConverter.appKitRectToCG(screen.frame)
    applyCapture(cgImage: cgImage, screenFrame: cgRect)
    return cgImage
}
```

Remove the inline `mainHeight - frame.origin.y - frame.height` conversion and the `guard let mainScreen` line — both replaced by `CoordinateConverter.appKitRectToCG()` and `ScreenCapture.captureScreen()`.

**RulerWindow.swift** — Add conformance to `OverlayWindow` protocol (from Plan 01). The window already has `targetScreen`, `showInitialState()`, `collapseHintBar()`, `deactivate()` — just declare conformance. If the protocol requires any methods that don't exist yet, add them.
  </action>
  <verify>Project builds: `cd /Users/haythem/Developer/design-ruler/swift/Ruler && swift build 2>&1 | tail -5`. Grep to confirm no duplicated lifecycle methods: `grep -c "handleExit\|setupSignalHandler\|resetInactivityTimer" swift/Ruler/Sources/Ruler.swift` should return 0.</verify>
  <done>Ruler.swift is a thin OverlayCoordinator subclass. EdgeDetector uses ScreenCapture. RulerWindow conforms to OverlayWindow. No duplicated lifecycle code in Ruler.swift.</done>
</task>

<task type="auto">
  <name>Task 2: Refactor AlignmentGuides.swift to use shared base</name>
  <files>
    swift/Ruler/Sources/AlignmentGuides/AlignmentGuides.swift
    swift/Ruler/Sources/AlignmentGuides/AlignmentGuidesWindow.swift
  </files>
  <action>
**AlignmentGuides.swift** — Rewrite to subclass OverlayCoordinator. The `@raycast func alignmentGuides()` stays in this file. After refactoring, AlignmentGuides should contain ONLY:

1. `@raycast func alignmentGuides(hideHintBar:)` — calls `AlignmentGuides.shared.run(hideHintBar:)` (NO warmup capture here — it moved into the base)
2. `class AlignmentGuides: OverlayCoordinator` with `static let shared = AlignmentGuides()`
3. Command-specific stored properties: `currentStyle: GuideLineStyle = .dynamic` and `currentDirection: Direction = .vertical`
4. Override `run(hideHintBar:)` — resets `currentStyle = .dynamic` and `currentDirection = .vertical`, then calls `super.run(hideHintBar: hideHintBar)`. The base handles everything else.
5. `captureAllScreens()` — can use the base's default implementation (which uses `ScreenCapture.captureScreen()`). Only override if the base default doesn't match. The existing AlignmentGuides capture is identical to what ScreenCapture provides, so no override needed.
6. Override `createWindow(for:image:isCursorScreen:hideHintBar:)` — creates `AlignmentGuidesWindow.create(for:screenshot:hideHintBar:)`, returns window.
7. Override `wireCallbacks(for:)` — calls `super.wireCallbacks(for:)` for the 4 standard callbacks, THEN adds the 4 extra AlignmentGuides-specific callbacks: `onSpacebarPressed`, `onSpacebarReleased`, `onTabPressed`, `onTabReleased`. Must downcast window to `AlignmentGuidesWindow` to wire these.
8. Override `activateWindow(_:)` — calls base logic for the common pattern, but additionally passes `currentStyle` and `currentDirection` to the window's `activate(firstMoveAlreadyReceived:currentStyle:currentDirection:)`.
9. Keep command-specific methods: `handleSpacebar()` and `handleTab()` — these are AlignmentGuides-only logic.

**Delete from AlignmentGuides.swift**: `captureScreen()`, `handleExit()`, `handleFirstMove()`, `setupSignalHandler()`, `resetInactivityTimer()`, all the duplicated stored properties (inactivityTimer, sigTermSource, launchTime, minExpandedDuration, inactivityTimeout, firstMoveReceived, activeWindow, cursorWindow, windows).

**AlignmentGuidesWindow.swift** — Add conformance to `OverlayWindow` protocol. The window already has `targetScreen`, `showInitialState()`, `collapseHintBar()`, `deactivate()` — just declare conformance.

**Critical detail for wireCallbacks**: The `onActivate` callback on AlignmentGuidesWindow takes `(AlignmentGuidesWindow) -> Void` while on RulerWindow it takes `(RulerWindow) -> Void`. The base class needs to handle this. Options:
- The base wires `onActivate` by casting to protocol and calling `self.activateWindow(window)` — but the callback type differs per window. The pragmatic solution: the base wires onRequestExit, onFirstMove, onActivity (which are `(() -> Void)?`). The subclass wires `onActivate` itself since it's the only callback with a typed parameter. OR the protocol includes `var onActivateAny: ((NSWindow) -> Void)?` as an alternative.
- Use your judgment from Plan 01's OverlayWindow protocol design — just ensure the 4 common callbacks get wired correctly.
  </action>
  <verify>
1. Project builds: `cd /Users/haythem/Developer/design-ruler/swift/Ruler && swift build 2>&1 | tail -5`
2. No duplicated lifecycle: `grep -c "handleExit\|setupSignalHandler\|resetInactivityTimer\|handleFirstMove" swift/Ruler/Sources/AlignmentGuides/AlignmentGuides.swift` should return 0 (these live in the base now)
3. No captureScreen in AlignmentGuides: `grep -c "captureScreen" swift/Ruler/Sources/AlignmentGuides/AlignmentGuides.swift` should return 0
4. Both `@raycast` entry points still exist: `grep "@raycast" swift/Ruler/Sources/Ruler.swift swift/Ruler/Sources/AlignmentGuides/AlignmentGuides.swift`
  </verify>
  <done>AlignmentGuides.swift is a thin OverlayCoordinator subclass with only command-specific logic (style/direction state, spacebar/tab handlers, window factory). No duplicated lifecycle code. Both commands build and the @raycast entry points are intact.</done>
</task>

</tasks>

<verification>
1. `swift build` succeeds in `/Users/haythem/Developer/design-ruler/swift/Ruler/`
2. `handleExit`, `handleFirstMove`, `setupSignalHandler`, `resetInactivityTimer` each appear exactly ONCE — in OverlayCoordinator.swift
3. `captureScreen` logic appears exactly ONCE — in ScreenCapture.swift (EdgeDetector delegates to it)
4. No inline `mainHeight - frame.origin.y - frame.height` rect conversion remains in EdgeDetector or AlignmentGuides
5. Both `@raycast func inspect` and `@raycast func alignmentGuides` entry points compile
6. Ruler.swift contains `class Ruler: OverlayCoordinator`
7. AlignmentGuides.swift contains `class AlignmentGuides: OverlayCoordinator`
8. `ray build` succeeds from project root (full Raycast build)
</verification>

<success_criteria>
- Both commands subclass OverlayCoordinator with only command-specific logic
- Zero duplicated lifecycle methods between Ruler.swift and AlignmentGuides.swift
- EdgeDetector uses ScreenCapture.captureScreen() instead of inline capture
- Both window types conform to OverlayWindow protocol
- Both commands build and maintain identical runtime behavior
</success_criteria>

<output>
After completion, create `.planning/phases/14-coordinator-base/14-02-SUMMARY.md`
</output>
