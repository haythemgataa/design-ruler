---
phase: 22-global-hotkeys
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - App/project.yml
  - App/Sources/HotkeyNames.swift
  - App/Sources/HotkeyController.swift
  - App/Sources/AppDelegate.swift
  - App/Sources/MenuBarController.swift
  - App/Design Ruler.xcodeproj/project.pbxproj
autonomous: true

must_haves:
  truths:
    - "Global hotkey for Measure fires from any application and launches the overlay"
    - "Global hotkey for Alignment Guides fires from any application and launches the overlay"
    - "Pressing same-command hotkey while overlay is active toggles it off instantly"
    - "Pressing cross-command hotkey while overlay is active closes current and launches the other"
    - "Menu bar dropdown shows assigned shortcut symbols next to each command name"
    - "App ships with no pre-assigned hotkeys (both start unassigned)"
  artifacts:
    - path: "App/Sources/HotkeyNames.swift"
      provides: "KeyboardShortcuts.Name extensions for .measure and .alignmentGuides"
    - path: "App/Sources/HotkeyController.swift"
      provides: "Session-aware hotkey dispatch (toggle-off, cross-switch, normal launch)"
    - path: "App/project.yml"
      provides: "KeyboardShortcuts 2.4.0 SPM dependency"
  key_links:
    - from: "App/Sources/HotkeyController.swift"
      to: "OverlayCoordinator.handleExit()"
      via: "toggle-off and cross-switch dispatch"
      pattern: "handleExit\\(\\)"
    - from: "App/Sources/AppDelegate.swift"
      to: "App/Sources/HotkeyController.swift"
      via: "onKeyUp handler registration"
      pattern: "onKeyUp"
    - from: "App/Sources/MenuBarController.swift"
      to: "App/Sources/HotkeyNames.swift"
      via: "NSMenuItem.setShortcut(for:)"
      pattern: "setShortcut"
---

<objective>
Add KeyboardShortcuts 2.4.0 dependency, define shortcut names, build session-aware hotkey dispatch, wire into AppDelegate, and connect menu item shortcut display.

Purpose: Enable global keyboard shortcuts that trigger overlay commands from any application, with toggle-off and cross-command switching behavior.
Output: Working hotkey infrastructure — pressing assigned shortcuts launches/toggles overlays, menu bar shows shortcut symbols.
</objective>

<execution_context>
@/Users/haythem/.claude/get-shit-done/workflows/execute-plan.md
@/Users/haythem/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-global-hotkeys/22-RESEARCH.md
@.planning/phases/22-global-hotkeys/22-CONTEXT.md
@.planning/phases/21-settings-and-preferences/21-01-SUMMARY.md
@.planning/phases/21-settings-and-preferences/21-02-SUMMARY.md

Key source files:
@App/Sources/AppDelegate.swift
@App/Sources/MenuBarController.swift
@App/project.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add KeyboardShortcuts dependency, create HotkeyNames and HotkeyController</name>
  <files>
    App/project.yml
    App/Sources/HotkeyNames.swift
    App/Sources/HotkeyController.swift
  </files>
  <action>
**1. Add KeyboardShortcuts SPM dependency to project.yml:**

In the `packages:` section, add:
```yaml
KeyboardShortcuts:
  url: https://github.com/sindresorhus/KeyboardShortcuts
  from: "2.4.0"
```

In the `targets: "Design Ruler": dependencies:` list, add:
```yaml
- package: KeyboardShortcuts
```

**2. Create HotkeyNames.swift:**

```swift
import KeyboardShortcuts

extension KeyboardShortcuts.Name {
    static let measure = Self("measure")
    static let alignmentGuides = Self("alignmentGuides")
}
```

No default shortcuts — both start unassigned per HOTK-03.

**3. Create HotkeyController.swift:**

Centralized session-aware hotkey dispatch. This class:
- Holds weak references to MenuBarController (for setActive) and launch closures
- Uses `onKeyUp` (not onKeyDown) to prevent key-repeat re-triggering
- Implements three dispatch paths: toggle-off, cross-switch, normal launch

```swift
import AppKit
import DesignRulerCore
import KeyboardShortcuts

final class HotkeyController {
    /// Which command is currently active (nil if no overlay running)
    private var activeCommand: Command?

    var onLaunchMeasure: (() -> Void)?
    var onLaunchAlignmentGuides: (() -> Void)?
    var onSetActive: ((Bool) -> Void)?

    enum Command {
        case measure
        case alignmentGuides
    }

    func registerHandlers() {
        KeyboardShortcuts.onKeyUp(for: .measure) { [weak self] in
            self?.handleHotkey(command: .measure)
        }
        KeyboardShortcuts.onKeyUp(for: .alignmentGuides) { [weak self] in
            self?.handleHotkey(command: .alignmentGuides)
        }
    }

    /// Called by AppDelegate when an overlay session starts via any trigger (menu bar or hotkey)
    func sessionStarted(command: Command) {
        activeCommand = command
    }

    /// Called by AppDelegate when onSessionEnd fires
    func sessionEnded() {
        activeCommand = nil
    }

    private func handleHotkey(command: Command) {
        if command == activeCommand {
            // Same command: toggle off (instant dismiss, same as ESC)
            switch command {
            case .measure:
                MeasureCoordinator.shared.handleExit()
            case .alignmentGuides:
                AlignmentGuidesCoordinator.shared.handleExit()
            }
        } else if activeCommand != nil {
            // Cross-command switch: close current, then launch other
            switch activeCommand! {
            case .measure:
                MeasureCoordinator.shared.handleExit()
            case .alignmentGuides:
                AlignmentGuidesCoordinator.shared.handleExit()
            }
            // Use DispatchQueue.main.async for autorelease pool drainage
            // per research pitfall #3
            DispatchQueue.main.async { [weak self] in
                self?.launchCommand(command)
            }
        } else {
            // No overlay active: normal launch
            launchCommand(command)
        }
    }

    private func launchCommand(_ command: Command) {
        guard !OverlayCoordinator.anySessionActive else { return }
        onSetActive?(true)
        switch command {
        case .measure:
            onLaunchMeasure?()
        case .alignmentGuides:
            onLaunchAlignmentGuides?()
        }
    }
}
```

Key design decisions:
- `activeCommand` tracks which command is running (separate from `anySessionActive` which is the coordinator's own guard)
- `sessionStarted`/`sessionEnded` are called by AppDelegate to keep HotkeyController in sync
- Toggle-off calls `handleExit()` directly — Carbon hotkeys swallow the event before NSWindow.keyDown, so no conflict with overlay's own key handling
- Cross-switch uses `DispatchQueue.main.async` between exit and relaunch for autorelease pool drainage
- `launchCommand` still checks `anySessionActive` guard as safety net
  </action>
  <verify>
Run `cd /Users/haythem/conductor/workspaces/design-ruler-v2/porto/App && xcodegen generate 2>&1` to regenerate project, then `xcodebuild -project "Design Ruler.xcodeproj" -scheme "Design Ruler" -configuration Debug build 2>&1 | tail -5` to verify build succeeds with new dependency.
Also verify `swift build` from the SPM root still works (Raycast path unaffected since KeyboardShortcuts is only in project.yml, not Package.swift).
  </verify>
  <done>
KeyboardShortcuts 2.4.0 resolves as SPM dependency. HotkeyNames.swift defines .measure and .alignmentGuides with no defaults. HotkeyController.swift compiles with toggle-off, cross-switch, and normal launch paths. xcodebuild BUILD SUCCEEDED. swift build still passes (Raycast unaffected).
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire HotkeyController into AppDelegate and add menu item shortcut display</name>
  <files>
    App/Sources/AppDelegate.swift
    App/Sources/MenuBarController.swift
  </files>
  <action>
**1. Update AppDelegate.swift:**

Add `import KeyboardShortcuts` at top.

Add a `private var hotkeyController: HotkeyController!` property.

In `applicationDidFinishLaunching`, AFTER creating menuBarController and wiring its callbacks:

```swift
// Create hotkey controller and wire launch callbacks
hotkeyController = HotkeyController()
hotkeyController.onLaunchMeasure = { [weak self] in
    let prefs = AppPreferences.shared
    MeasureCoordinator.shared.run(hideHintBar: prefs.hideHintBar, corrections: prefs.corrections)
}
hotkeyController.onLaunchAlignmentGuides = {
    AlignmentGuidesCoordinator.shared.run(hideHintBar: AppPreferences.shared.hideHintBar)
}
hotkeyController.onSetActive = { [weak self] active in
    self?.menuBarController.setActive(active)
}
hotkeyController.registerHandlers()
```

Update the existing menuBarController.onMeasure and onAlignmentGuides closures to also notify hotkeyController of session start:

```swift
menuBarController.onMeasure = { [weak self] in
    let prefs = AppPreferences.shared
    self?.hotkeyController.sessionStarted(command: .measure)
    MeasureCoordinator.shared.run(hideHintBar: prefs.hideHintBar, corrections: prefs.corrections)
}
menuBarController.onAlignmentGuides = { [weak self] in
    self?.hotkeyController.sessionStarted(command: .alignmentGuides)
    AlignmentGuidesCoordinator.shared.run(hideHintBar: AppPreferences.shared.hideHintBar)
}
```

Update the onSessionEnd callbacks to also notify hotkeyController:

```swift
MeasureCoordinator.shared.onSessionEnd = { [weak self] in
    self?.menuBarController.setActive(false)
    self?.hotkeyController.sessionEnded()
}
AlignmentGuidesCoordinator.shared.onSessionEnd = { [weak self] in
    self?.menuBarController.setActive(false)
    self?.hotkeyController.sessionEnded()
}
```

**2. Update MenuBarController.swift:**

Add `import KeyboardShortcuts` at top.

In `setupMenu()`, after creating `measureItem` and `guidesItem`, add shortcut display:

```swift
measureItem.setShortcut(for: .measure)
guidesItem.setShortcut(for: .alignmentGuides)
```

This automatically:
- Shows the shortcut symbols right-aligned (e.g., "Measure  Cmd+Shift+M") when assigned
- Shows nothing when unassigned (just the command name)
- Updates dynamically when user changes shortcuts in Settings

**Important:** `setShortcut(for:)` uses KVO to observe UserDefaults changes, so it auto-updates without manual refresh.
  </action>
  <verify>
Run `cd /Users/haythem/conductor/workspaces/design-ruler-v2/porto/App && xcodebuild -project "Design Ruler.xcodeproj" -scheme "Design Ruler" -configuration Debug build 2>&1 | tail -5` to verify build succeeds.
Grep AppDelegate.swift for `hotkeyController` to confirm wiring.
Grep MenuBarController.swift for `setShortcut` to confirm menu display.
Grep AppDelegate.swift for `sessionStarted` and `sessionEnded` to confirm session tracking.
  </verify>
  <done>
AppDelegate creates HotkeyController, registers onKeyUp handlers, and wires session start/end tracking. MenuBarController displays assigned shortcut symbols next to command names in the dropdown. Both xcodebuild and swift build pass.
  </done>
</task>

</tasks>

<verification>
1. `xcodebuild` Debug build succeeds with KeyboardShortcuts dependency resolved
2. `swift build` (Raycast SPM path) still succeeds — KeyboardShortcuts not in Package.swift
3. HotkeyNames.swift defines .measure and .alignmentGuides with no default shortcuts
4. HotkeyController.swift has three dispatch paths: toggle-off (same command), cross-switch (different command), normal launch (no active overlay)
5. AppDelegate registers onKeyUp handlers and tracks session state
6. MenuBarController uses NSMenuItem.setShortcut(for:) for both commands
7. No grep hits for default shortcuts (KeyboardShortcuts.Name constructors have no `default:` parameter)
</verification>

<success_criteria>
- KeyboardShortcuts 2.4.0 is an SPM dependency in project.yml (not Package.swift)
- Shortcut names defined with no defaults — both start unassigned
- HotkeyController handles toggle-off, cross-switch, and normal launch
- AppDelegate wires hotkey handlers and session tracking
- Menu items display shortcut symbols when assigned, nothing when unassigned
- Both xcodebuild and swift build pass
</success_criteria>

<output>
After completion, create `.planning/phases/22-global-hotkeys/22-01-SUMMARY.md`
</output>
