---
phase: 19-app-lifecycle-refactor
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - swift/DesignRuler/Sources/DesignRulerCore/Utilities/OverlayCoordinator.swift
autonomous: true

must_haves:
  truths:
    - "OverlayCoordinator has a RunMode enum with .raycast and .standalone cases"
    - "app.run() only executes when runMode is .raycast"
    - "NSApp.terminate(nil) only executes when runMode is .raycast"
    - "isSessionActive guard rejects overlapping invocations from the same coordinator"
    - "OverlayCoordinator.anySessionActive static flag rejects invocations across different coordinators"
    - "CursorManager.shared.restore() runs at the start of every new session"
    - "handleExit() clears isSessionActive synchronously before any cleanup"
    - "Default runMode is .raycast so existing Raycast bridge code requires zero changes"
  artifacts:
    - path: "swift/DesignRuler/Sources/DesignRulerCore/Utilities/OverlayCoordinator.swift"
      provides: "RunMode enum, isSessionActive guard, anySessionActive cross-coordinator guard, gated app.run/terminate, cursor reset"
      contains: "public enum RunMode"
  key_links:
    - from: "OverlayCoordinator.run()"
      to: "app.run()"
      via: "if runMode == .raycast conditional"
      pattern: "if runMode == .raycast.*app\\.run"
    - from: "OverlayCoordinator.handleExit()"
      to: "NSApp.terminate(nil)"
      via: "if runMode == .raycast conditional"
      pattern: "if runMode == .raycast.*terminate"
---

<objective>
Add RunMode awareness and session lifecycle guards to OverlayCoordinator so it can be invoked from a persistent app without starting or killing the event loop.

Purpose: The coordinator currently assumes it owns the process (calls app.run() to start the event loop, NSApp.terminate(nil) to kill it). In the standalone app, the event loop is already running and ESC must end the overlay session without killing the process. This plan gates both calls behind a RunMode check and adds the re-invocation guard and cursor state reset required for clean multi-session behavior.

Output: Modified OverlayCoordinator.swift with RunMode enum, isSessionActive boolean, gated app.run()/terminate(), and CursorManager.restore() at session start.
</objective>

<execution_context>
@/Users/haythem/.claude/get-shit-done/workflows/execute-plan.md
@/Users/haythem/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-app-lifecycle-refactor/19-RESEARCH.md
@swift/DesignRuler/Sources/DesignRulerCore/Utilities/OverlayCoordinator.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add RunMode enum, session guard, and gated lifecycle to OverlayCoordinator</name>
  <files>swift/DesignRuler/Sources/DesignRulerCore/Utilities/OverlayCoordinator.swift</files>
  <action>
Modify OverlayCoordinator.swift with these specific changes:

**1. Add RunMode enum** — before the `open class OverlayCoordinator` declaration, add:
```swift
public enum RunMode {
    case raycast    // Event loop owned by coordinator; terminate kills process
    case standalone // Event loop owned by AppDelegate; session ends without killing app
}
```

**2. Add properties** — inside OverlayCoordinator, add these new properties:
```swift
public static var anySessionActive = false  // Cross-coordinator guard: prevents Measure + Guides overlap
public var runMode: RunMode = .raycast      // Default .raycast: zero changes needed in RaycastBridge
public var isSessionActive = false
```

**3. Modify `run(hideHintBar:)`** — add session guard and cursor reset at the TOP of the method, before the warmup capture. Order matters (matches RESEARCH.md Pitfall 4):
```swift
guard !isSessionActive else { return }           // Same-coordinator re-invocation guard
guard !OverlayCoordinator.anySessionActive else { return }  // Cross-coordinator guard
CursorManager.shared.restore()                   // Clean cursor state for new session (AFTER guards — must not run mid-session)
isSessionActive = true
OverlayCoordinator.anySessionActive = true
```
The ordering is: guards first (fast-reject without side effects), then restore() (safe because no session is active), then mark active. Calling restore() before the guards would unhide the cursor mid-session if a re-invocation is rejected.

Then gate `app.run()` at the BOTTOM of the method. Replace the bare `app.run()` call (currently the last line) with:
```swift
if runMode == .raycast {
    app.run()
}
// Standalone: returns immediately, AppDelegate's event loop continues
```

**4. Modify `handleExit()`** — make these changes to the existing method:

a. Set `isSessionActive = false` as the FIRST line (synchronous, before any cleanup — allows instant re-invocation per user decision).

b. Add `orderOut(nil)` before `close()` for each window (instant visual removal — "instant vanish" per user decision).

c. After the window loop, add cleanup: `windows.removeAll()`, `activeWindow = nil`, `cursorWindow = nil`.

d. Add timer and signal cleanup: `inactivityTimer?.invalidate()`, `inactivityTimer = nil`, `sigTermSource?.cancel()`, `sigTermSource = nil`.

e. Gate `NSApp.terminate(nil)` with `if runMode == .raycast { ... }`.

The final handleExit() should look like:
```swift
public func handleExit() {
    isSessionActive = false                    // synchronous first — allows instant re-invocation
    OverlayCoordinator.anySessionActive = false // cross-coordinator guard cleared
    CursorManager.shared.restore()
    inactivityTimer?.invalidate()
    inactivityTimer = nil
    sigTermSource?.cancel()
    sigTermSource = nil
    for window in windows {
        window.orderOut(nil)                   // instant visual removal
        window.close()
    }
    windows.removeAll()
    activeWindow = nil
    cursorWindow = nil
    if runMode == .raycast {
        NSApp.terminate(nil)
    }
    // Standalone: returns here, process stays alive
}
```

**5. Keep `setActivationPolicy(.accessory)` in `run()`** — do NOT remove it. The Raycast binary has no AppDelegate, so removing it would break Raycast mode. The call is idempotent. (The prior decision to "remove from coordinator" is superseded by the research finding in 19-RESEARCH.md Pitfall 6.)

**What NOT to change:**
- Do NOT modify resetCommandState(), captureAllScreens(), createWindow(), wireCallbacks(), or activateWindow() — those are subclass-specific and not affected by lifecycle changes.
- Do NOT modify RaycastBridge/Measure.swift or RaycastBridge/AlignmentGuides.swift — the default `.raycast` runMode means they work identically to before.
- Do NOT modify CursorManager.swift — its existing `restore()` method already handles all edge cases.
  </action>
  <verify>
1. Run `cd /Users/haythem/conductor/workspaces/design-ruler-v2/porto && ray build` — must succeed (Raycast extension behavior unchanged).
2. Run `cd /Users/haythem/conductor/workspaces/design-ruler-v2/porto/App && xcodebuild build -project "Design Ruler.xcodeproj" -scheme "Design Ruler" -configuration Debug 2>&1 | tail -5` — must show BUILD SUCCEEDED.
3. Grep for `public enum RunMode` in OverlayCoordinator.swift — must exist.
4. Grep for `guard !isSessionActive else { return }` in OverlayCoordinator.swift — must exist.
5. Grep for `if runMode == .raycast` in OverlayCoordinator.swift — must appear twice (once for app.run(), once for terminate).
6. Grep for `anySessionActive` in OverlayCoordinator.swift — must appear in property declaration, run() guard, and handleExit() clearing.
7. Grep for `sigTermSource?.cancel()` in OverlayCoordinator.swift — must exist inside handleExit() (prevents dangling SIGTERM handler calling handleExit() on a stale coordinator).
  </verify>
  <done>
OverlayCoordinator has RunMode enum with .raycast default, isSessionActive boolean guard, anySessionActive cross-coordinator static guard, CursorManager.restore() at session start (after guards, before marking active), app.run() gated behind .raycast check, NSApp.terminate(nil) gated behind .raycast check, handleExit() clears both isSessionActive and anySessionActive synchronously before cleanup, and sigTermSource is cancelled in handleExit(). Both ray build and xcodebuild succeed.
  </done>
</task>

</tasks>

<verification>
1. `ray build` passes — Raycast extension builds correctly with zero changes to bridge files
2. `xcodebuild build` passes — App target compiles with updated DesignRulerCore
3. `public enum RunMode` exists in OverlayCoordinator.swift
4. `isSessionActive = false` is the first statement in handleExit()
5. `if runMode == .raycast` gates both `app.run()` and `NSApp.terminate(nil)`
6. `CursorManager.shared.restore()` is called in `run()` after both guards but before `isSessionActive = true`
7. `setActivationPolicy(.accessory)` is still present in `run()` (not removed)
8. `OverlayCoordinator.anySessionActive` static flag exists, is set/cleared alongside `isSessionActive`, and is checked in `run()` guard
9. `sigTermSource?.cancel()` exists inside `handleExit()` (cleanup prevents stale SIGTERM handler)
</verification>

<success_criteria>
- OverlayCoordinator.swift contains RunMode enum, isSessionActive guard, anySessionActive cross-coordinator guard, gated app.run()/terminate(), cursor restore at session start
- Raycast build (`ray build`) passes with no changes to RaycastBridge files
- Xcode build (`xcodebuild build`) passes
</success_criteria>

<output>
After completion, create `.planning/phases/19-app-lifecycle-refactor/19-01-SUMMARY.md`
</output>
