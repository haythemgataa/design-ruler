---
phase: 19-app-lifecycle-refactor
plan: 02
type: execute
wave: 2
depends_on: ["19-01"]
files_modified:
  - swift/DesignRuler/Sources/DesignRulerCore/Measure/MeasureCoordinator.swift
  - swift/DesignRuler/Sources/DesignRulerCore/AlignmentGuides/AlignmentGuidesCoordinator.swift
  - swift/DesignRuler/Sources/RaycastBridge/Measure.swift
  - swift/DesignRuler/Sources/RaycastBridge/AlignmentGuides.swift
  - App/Sources/AppDelegate.swift
autonomous: true

must_haves:
  truths:
    - "Invoke Measure from AppDelegate, press ESC — the app process remains alive"
    - "Invoke Measure a second time immediately after ESC — second session launches with no cursor glitch or residual state"
    - "Raycast extension behavior is unchanged: pressing ESC still terminates the Raycast process as before"
    - "Re-invocation while a session is active is silently ignored"
    - "Different command triggered while one is active is silently ignored (via OverlayCoordinator.anySessionActive from Plan 19-01)"
    - "State is completely fresh every session — no selections, skip counts, guide lines, or style/direction carried over"
  artifacts:
    - path: "swift/DesignRuler/Sources/DesignRulerCore/Measure/MeasureCoordinator.swift"
      provides: "Measure coordinator subclass accessible from both App and RaycastBridge"
      contains: "open class MeasureCoordinator"
    - path: "swift/DesignRuler/Sources/DesignRulerCore/AlignmentGuides/AlignmentGuidesCoordinator.swift"
      provides: "AlignmentGuides coordinator subclass accessible from both App and RaycastBridge"
      contains: "open class AlignmentGuidesCoordinator"
    - path: "swift/DesignRuler/Sources/RaycastBridge/Measure.swift"
      provides: "Thin @raycast wrapper calling MeasureCoordinator.shared"
      contains: "@raycast func inspect"
    - path: "swift/DesignRuler/Sources/RaycastBridge/AlignmentGuides.swift"
      provides: "Thin @raycast wrapper calling AlignmentGuidesCoordinator.shared"
      contains: "@raycast func alignmentGuides"
    - path: "App/Sources/AppDelegate.swift"
      provides: "Standalone app entry point setting .standalone runMode"
      contains: "runMode = .standalone"
  key_links:
    - from: "App/Sources/AppDelegate.swift"
      to: "MeasureCoordinator.shared"
      via: "import DesignRulerCore; sets runMode = .standalone; calls run()"
      pattern: "MeasureCoordinator\\.shared"
    - from: "RaycastBridge/Measure.swift"
      to: "MeasureCoordinator.shared"
      via: "import DesignRulerCore; uses default .raycast runMode"
      pattern: "MeasureCoordinator\\.shared\\.run"
    - from: "RaycastBridge/AlignmentGuides.swift"
      to: "AlignmentGuidesCoordinator.shared"
      via: "import DesignRulerCore; uses default .raycast runMode"
      pattern: "AlignmentGuidesCoordinator\\.shared\\.run"
---

<objective>
Move coordinator subclasses to DesignRulerCore so the standalone App target can invoke overlay sessions, and wire AppDelegate for standalone mode testing.

Purpose: The `Measure` and `AlignmentGuides` coordinator subclasses currently live in `RaycastBridge` (an executable target), which cannot be imported by the `App` target. Success criterion #1 requires invoking Measure from AppDelegate, which only imports `DesignRulerCore`. This plan moves the coordinator subclass logic to `DesignRulerCore` (as `MeasureCoordinator` and `AlignmentGuidesCoordinator`), reduces `RaycastBridge` files to thin `@raycast` wrappers, and wires `AppDelegate` to set `.standalone` runMode and invoke the coordinator.

Output: MeasureCoordinator and AlignmentGuidesCoordinator in DesignRulerCore, thin RaycastBridge wrappers, AppDelegate wired for standalone mode with a temporary test invocation for verifying success criteria.
</objective>

<execution_context>
@/Users/haythem/.claude/get-shit-done/workflows/execute-plan.md
@/Users/haythem/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-app-lifecycle-refactor/19-RESEARCH.md
@.planning/phases/19-app-lifecycle-refactor/19-01-SUMMARY.md
@swift/DesignRuler/Sources/DesignRulerCore/Utilities/OverlayCoordinator.swift
@swift/DesignRuler/Sources/RaycastBridge/Measure.swift
@swift/DesignRuler/Sources/RaycastBridge/AlignmentGuides.swift
@App/Sources/AppDelegate.swift
@App/project.yml
@swift/DesignRuler/Package.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Move coordinator subclasses to DesignRulerCore and slim RaycastBridge wrappers</name>
  <files>
    swift/DesignRuler/Sources/DesignRulerCore/Measure/MeasureCoordinator.swift
    swift/DesignRuler/Sources/DesignRulerCore/AlignmentGuides/AlignmentGuidesCoordinator.swift
    swift/DesignRuler/Sources/RaycastBridge/Measure.swift
    swift/DesignRuler/Sources/RaycastBridge/AlignmentGuides.swift
  </files>
  <action>
**1. Create `MeasureCoordinator.swift`** in `DesignRulerCore/Measure/`:

Move ALL the coordinator subclass logic from `RaycastBridge/Measure.swift` into a new `open class MeasureCoordinator: OverlayCoordinator` in DesignRulerCore. This includes:
- `static let shared = MeasureCoordinator()` (public)
- `private var correctionMode: CorrectionMode = .smart`
- `private var detectors: [ObjectIdentifier: EdgeDetector] = [:]`
- `public func run(hideHintBar: Bool, corrections: String)` — sets correctionMode, calls super.run()
- All overrides: `resetCommandState()`, `captureAllScreens()`, `createWindow(for:image:isCursorScreen:hideHintBar:)`, `wireCallbacks(for:)`, `activateWindow(_:)`

The class must be `open` (not `final`) since it's in a library target and needs to be subclassable if ever needed. All methods that were previously `override` remain `override`. Access level: `open class`, `public static let shared`, public `run(hideHintBar:corrections:)`. Private members stay private.

**2. Create `AlignmentGuidesCoordinator.swift`** in `DesignRulerCore/AlignmentGuides/`:

Move ALL the coordinator subclass logic from `RaycastBridge/AlignmentGuides.swift` into a new `open class AlignmentGuidesCoordinator: OverlayCoordinator` in DesignRulerCore. This includes:
- `static let shared = AlignmentGuidesCoordinator()` (public)
- `private(set) var currentStyle: GuideLineStyle = .dynamic`
- `private var currentDirection: Direction = .vertical`
- All overrides: `resetCommandState()`, `createWindow(for:image:isCursorScreen:hideHintBar:)`, `wireCallbacks(for:)`, `activateWindow(_:)`
- Private methods: `handleSpacebar()`, `handleTab()`

Same access level pattern: `open class`, `public static let shared`.

**3. Slim `RaycastBridge/Measure.swift`** — replace the entire file content with a thin wrapper:
```swift
import RaycastSwiftMacros
import DesignRulerCore

@raycast func inspect(hideHintBar: Bool, corrections: String) {
    MeasureCoordinator.shared.run(hideHintBar: hideHintBar, corrections: corrections)
}
```

That's it. No class definition. The `@raycast` macro only needs the function declaration. `MeasureCoordinator` is imported from `DesignRulerCore`.

**4. Slim `RaycastBridge/AlignmentGuides.swift`** — replace with:
```swift
import RaycastSwiftMacros
import DesignRulerCore

@raycast func alignmentGuides(hideHintBar: Bool) {
    AlignmentGuidesCoordinator.shared.run(hideHintBar: hideHintBar)
}
```

**Important:**
- Do NOT modify `Package.swift` — the new files are in existing source directories that SPM already scans.
- All types referenced by the coordinator subclasses (EdgeDetector, MeasureWindow, AlignmentGuidesWindow, GuideLineStyle, Direction, CorrectionMode, ScreenCapture, CursorManager, etc.) are already in DesignRulerCore, so no import changes are needed inside the new files — just `import AppKit`.
- The `import AppKit` at the top of each new file is sufficient since DesignRulerCore is the same module.
  </action>
  <verify>
1. Run `cd /Users/haythem/conductor/workspaces/design-ruler-v2/porto && ray build` — must succeed (Raycast bridge still calls the same coordinator logic, just from a different module location).
2. Run `cd /Users/haythem/conductor/workspaces/design-ruler-v2/porto/App && xcodebuild build -project "Design Ruler.xcodeproj" -scheme "Design Ruler" -configuration Debug 2>&1 | tail -5` — must show BUILD SUCCEEDED.
3. Verify `MeasureCoordinator.swift` exists in `DesignRulerCore/Measure/`.
4. Verify `AlignmentGuidesCoordinator.swift` exists in `DesignRulerCore/AlignmentGuides/`.
5. Verify `RaycastBridge/Measure.swift` has no class definition (only `@raycast func` + import).
6. Verify `RaycastBridge/AlignmentGuides.swift` has no class definition (only `@raycast func` + import).
7. Grep for `detectors.removeAll()` in `DesignRulerCore/Measure/MeasureCoordinator.swift` — must exist in `resetCommandState()` override (confirms fresh state per session was not dropped during the move).
  </verify>
  <done>
MeasureCoordinator and AlignmentGuidesCoordinator exist in DesignRulerCore with full coordinator subclass logic. RaycastBridge files are thin @raycast wrappers only. Both ray build and xcodebuild succeed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire AppDelegate for standalone mode with test invocation</name>
  <files>App/Sources/AppDelegate.swift</files>
  <action>
Update `App/Sources/AppDelegate.swift` to:

1. Add `import DesignRulerCore` (it already imports AppKit).

2. In `applicationDidFinishLaunching(_:)`:
   a. Set `NSApp.setActivationPolicy(.accessory)` — this ensures the app is an agent (no Dock icon) from the very start, before any overlay session.
   b. Set `MeasureCoordinator.shared.runMode = .standalone` and `AlignmentGuidesCoordinator.shared.runMode = .standalone` — these singletons persist for the app lifetime, so runMode only needs to be set once.
   c. Add a temporary test invocation for verifying success criteria: call `MeasureCoordinator.shared.run(hideHintBar: false, corrections: "smart")` after a short delay (e.g., `DispatchQueue.main.asyncAfter(deadline: .now() + 0.5)`) to allow the app to fully launch first. Mark this with a `// TEMP: Phase 19 test — remove in Phase 20 when menu bar triggers overlays` comment.

3. Keep `applicationShouldTerminateAfterLastWindowClosed` returning `false` — already correct.

The final AppDelegate should look approximately like:
```swift
import AppKit
import DesignRulerCore

@main
class AppDelegate: NSObject, NSApplicationDelegate {
    func applicationDidFinishLaunching(_ notification: Notification) {
        NSApp.setActivationPolicy(.accessory)

        // Configure coordinators for standalone mode (event loop already running)
        MeasureCoordinator.shared.runMode = .standalone
        AlignmentGuidesCoordinator.shared.runMode = .standalone

        // TEMP: Phase 19 test — remove in Phase 20 when menu bar triggers overlays
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            MeasureCoordinator.shared.run(hideHintBar: false, corrections: "smart")
        }
    }

    func applicationShouldTerminateAfterLastWindowClosed(_ sender: NSApplication) -> Bool {
        return false
    }
}
```

**What NOT to do:**
- Do NOT add a menu bar item yet — that's Phase 20.
- Do NOT remove the `applicationShouldTerminateAfterLastWindowClosed` override — it prevents the app from quitting when overlay windows close.
  </action>
  <verify>
1. Run `cd /Users/haythem/conductor/workspaces/design-ruler-v2/porto/App && xcodebuild build -project "Design Ruler.xcodeproj" -scheme "Design Ruler" -configuration Debug 2>&1 | tail -5` — must show BUILD SUCCEEDED.
2. Grep for `runMode = .standalone` in AppDelegate.swift — must appear twice (Measure and AlignmentGuides).
3. Grep for `import DesignRulerCore` in AppDelegate.swift — must exist.
4. Grep for `MeasureCoordinator.shared.run` in AppDelegate.swift — must exist (temporary test invocation).
5. Run `cd /Users/haythem/conductor/workspaces/design-ruler-v2/porto && ray build` — must still succeed (AppDelegate changes are in App target only, not in RaycastBridge).
  </verify>
  <done>
AppDelegate imports DesignRulerCore, sets .standalone runMode on both coordinator singletons, includes a temporary Measure invocation for Phase 19 success criteria testing. Both xcodebuild and ray build succeed. The app process will stay alive after ESC because handleExit() gates NSApp.terminate(nil) behind .raycast mode.
  </done>
</task>

</tasks>

<verification>
**Phase-level verification (all three success criteria from ROADMAP.md):**

1. **SC-1: Invoke Measure from AppDelegate, press ESC — app process remains alive**
   - AppDelegate sets .standalone mode and calls MeasureCoordinator.shared.run()
   - handleExit() gates NSApp.terminate(nil) behind `if runMode == .raycast`
   - Process stays alive after ESC

2. **SC-2: Invoke Measure a second time immediately after ESC — no cursor glitch or residual state**
   - isSessionActive cleared synchronously as first line of handleExit()
   - CursorManager.shared.restore() called at start of every run()
   - resetCommandState() called in run() step 4 (detectors.removeAll() for Measure)
   - Windows torn down completely in handleExit(): orderOut, close, removeAll, nil activeWindow/cursorWindow

3. **SC-3: Raycast extension behavior unchanged — ESC terminates process**
   - RunMode defaults to .raycast
   - RaycastBridge files never set runMode
   - app.run() and NSApp.terminate(nil) execute as before in .raycast mode

**Build verification:**
- `ray build` passes (Raycast extension unchanged)
- `xcodebuild build` passes (App target compiles with DesignRulerCore)
</verification>

<success_criteria>
- MeasureCoordinator and AlignmentGuidesCoordinator exist in DesignRulerCore
- RaycastBridge files are thin @raycast wrappers (no coordinator class definitions)
- AppDelegate sets .standalone runMode and invokes MeasureCoordinator
- Both `ray build` and `xcodebuild build` pass
- All three phase success criteria are structurally satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/19-app-lifecycle-refactor/19-02-SUMMARY.md`
</output>
